\documentclass[letterpaper,12pt,oneside]{book}
\usepackage[top=1in, left=0.9in, right=1.25in, bottom=1in]{geometry}
\usepackage{bachelorstitlepageUNAM}
\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{graphicx}
\usepackage{tikz} 
\usepackage{tocloft}
\graphicspath{{./figs/}}
\usepackage{setspace}
\usepackage{minted}
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}

\newcommand{\coq}{\textbf{Coq}}
\newcommand{\ARNs}{Arboles Roji-negros }
\newcommand{\ARN}{Árbol Roji-negro }
\newcommand{\arn}{árbol roji-negro }
\newcommand{\arns}{arboles roji-negros }
%\usepackage[round]{natbib}

%para pintar arboles bonitos...
\usepackage{tikz}
\usetikzlibrary{arrows}
%\usetikzlibrary{arrows}


\tikzset{
treenode/.style = {align=center, inner sep=0pt, text centered,
font=\sffamily},
arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
fill=black, text width=1.5em},% arbre rouge noir, noeud noir
arn_r/.style = {treenode, circle, white, draw=red, fill= red,
text width=1.5em, very thick},% arbre rouge noir, noeud rouge
arn_x/.style = {treenode, rectangle, white, draw=black, fill= black,
minimum width=0.5em, minimum height=0.5em},% arbre rouge noir, nil
arn_bb/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=gray,
fill=gray, text width=1.5em},
arn_nb/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
fill=white, text width=1.5em},
arn_w/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=brown,
fill=brown, text width=1.5em},
arn_xb/.style = {treenode, rectangle, white, draw=gray, fill= gray,
minimum width=0.5em, minimum height=0.5em}
}

\renewcommand\cftsecpresnum{\S}
\renewcommand\cftsubsecpresnum{\S}   

\theoremstyle{plain}
\newtheorem{thm}{Teorema}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposici\'on}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definci\'on}[section]
\newtheorem{exmp}{Ejemplo}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}


\begin{document}
%------------------------------

\begin{titlepage}
\thispagestyle{empty}
\begin{minipage}[c][0.17\textheight][c]{0.25\textwidth}
\begin{center}
\includegraphics[width=3.5cm, height=3.5cm]{Escudo-UNAM.pdf}
\end{center}
\end{minipage}
\begin{minipage}[c][0.195\textheight][t]{0.75\textwidth}
\begin{center}
\vspace{0.3cm}
\textsc{\large Universidad Nacional Aut\'onoma de M\'exico}\\[0.5cm]
\vspace{0.3cm}
\hrule height2.5pt
\vspace{.2cm}
\hrule height1pt
\vspace{.8cm}
\textsc{Facultad de Ciencias}\\[0.5cm] %
\end{center}
\end{minipage}

\begin{minipage}[c][0.81\textheight][t]{0.25\textwidth}
\vspace*{5mm}
\begin{center}
\hskip2.0mm
\vrule width1pt height13cm 
\vspace{5mm}
\hskip2pt
\vrule width2.5pt height13cm
\hskip2mm
\vrule width1pt height13cm \\
\vspace{5mm}
\includegraphics[height=4.0cm]{Escudo-FCIENCIAS.pdf}
\end{center}
\end{minipage}
\begin{minipage}[c][0.81\textheight][t]{0.75\textwidth}
\begin{center}
\vspace{1cm}

{\large\scshape Verificación formal de arboles roji-negros}\\[.2in]

\vspace{2cm}            

\textsc{\LARGE T\hspace{1.5cm}E\hspace{1.5cm}S\hspace{1.5cm}I\hspace{1.5cm}S}\\[0.5cm]
\textsc{\large que para obtener el t\'itulo de:}\\[0.5cm]
\textsc{\large Licenciado en Ciencias de la Computación}\\[0.5cm]
\textsc{\large presenta:}\\[0.5cm]
\textsc{\large {David Felipe Hern\'andez Chiapa}}\\[2cm]          

\vspace{0.5cm}

{\large\scshape Tutores:\\[0.3cm] {Dra. Lourdes del Carmen Gonzalez Huesca}}\\[.2in]

\vspace{0.5cm}

\large{Ciudad Universitaria, Ciudad de México,}{ }{2019}
\end{center}
\end{minipage}
\end{titlepage}



%---------------------------------
\frontmatter
%\maketitle
\chapter*{}
\begin{flushright}%
\emph{Dedicatoria ...}
\thispagestyle{empty}
\end{flushright}

\chapter{Agradecimientos}
\spacing{1.5}%\doublespacing

\tableofcontents
\listoffigures


\mainmatter

\chapter{Introducción} 
\section{Motivación}
\section{Arboles Roji-negros}
Los \arns son una estructura de datos donde las operaciones de inserci\'on, eliminaci\'on y búsqueda se efectúan
en tiempo logarítmico, es decir, la complejidad de esas operaciones es $O(log(n))$, estos son una subclase de los
arboles binarios de búsqueda, en los cuales la complejidad crece hasta $O(n)$. Esta mejora en la complejidad se obtiene 
gracias a la introducción de colores en los nodos del \'arbol y también a invariantes, las cuales describiremos 
mas adelante.
\subsection{Definici\'on de \arns}
Un \arn se define de la siguiente manera:
\begin{defn}
Un \'arbol binario de búsqueda es un \arn si satisface lo siguiente:
\begin{enumerate}
    \item Todos sus nodos son rojos o negros.
    \item El \'arbol vació es negro.
    \item La raíz es negra.
    \item Las siguientes invariantes se tienen que cumplir:
    \begin{itemize}
        \item Un nodo rojo debe tener hijos negros.
        \item Todos los caminos de la raíz a las hojas deben tener la misma cantidad de nodos negros.
    \end{itemize}
\end{enumerate}
\end{defn}
Se presentan en la Figura 1, ejemplos visuales de \arns. Se muestran dos variantes, uno con nodos vacíos en las hojas
y el otro sin estos.

\hspace*{5cm}
\begin{figure}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;
\draw node [text width=7cm] at (-1,-4.5)
{
\'Arbol roji-negro con vac\'ios.
}
;
\node [arn_n] at (5,0) {6}
    child{ node [arn_r] {2} 
        child{ node [arn_n] {1}}
        child{ node [arn_n] {4}
            child{ node [arn_r] {3}}
            child{ node [arn_r] {5}}
        }                            
    }
    child{ node [arn_n] {8}
        child{ node [arn_r] {9}}
    }
;
\draw node [text width=7cm] at (7,-4.5)
{
\'Arbol roji-negro.
}
;
\end{tikzpicture}
\centering Figura 1.
\end{figure}
Nos interesa estudiar este tipo no trivial de arboles binarios de búsqueda para poder
demostrar la correcci'on de estos usando el asistente de pruebas \coq y así poder mostrar las ventajas, 
y problemáticas de este proceso.
\section{Traducción de Haskell a \coq (hs-to-coq)}

\chapter{Implementación de arboles roji-negros en \coq}

\section{Traducción de implementaciones}
Se tuvieron varias aproximaciones para la implementación de \arns; la primera fue obtener las implementaciones en
Haskell de estos\cite{tesisG} y pasarlo como entrada a hs-to-coq, la 
segunda aproximación, y la que se uso para esta tesis, fue obtener la implementación de Okasaki traducida a Coq 
(paginda de Coq), pero en lugar de usar las bibliotecas d tipos de Coq, se usaron los tipos de haskell.
A continuación profundizar/'e acerca de esos dos métodos.
\subsection{Traducción directa de implementaciones de Haskell a Coq}
En un trabajo anterior, realizado por Gabriela, se obtuvieron diversas implementaciones de \arns la mayor parte de estas
cambiaba mayormente en las implementaciones de las operaciones de borrado, siendo esta la operación mas compleja. 
Estas diversas implementaciones van desde la simple implementación de Okasaki, constructores inteligentes y tipos anidados.

Por la compleja naturaleza de estas implementaciones la traducción a mano del código de Haskell resultaba ser muy problemática,
ya que las implementaciones en Haskell se aprovechan del hecho de que en este lenguaje se pueden dar funciones parciales, 
lo cual resulta ser un problema al momento de traducir a Coq, ya que Coq únicamente acepta funciones totales.

Se opto usar la herramienta hs-to-coq para facilitar esta traducci\'on, pero por las mismas razones antes descritas (totalidad de funciones),
la herramienta se ciclaba al momento de tratar de traducir el c\'odigo de Haskell. 

Se busco otra acercamiento para poder verificar esta estructura; la herramienta hs-to-coq tiene una gran parte de las bibliotecas de Haskell 
traducidas a Coq, entonces usamos la implementación de \arns de las bibliotecas de \coq pero usando los tipos y comparaciones de tipos de Haskell.


\section{Inserción de elementos en un \ARN}

La inserci\'on de elementos a un \arn es la mas sencilla de de las dos operaciones que tiene esta estructura. La idea detrás de este algoritmo es que 
solo se agreguen hojas al \'arbol y se efectúen `giros` para mantener las invariantes de la estructura.
\subsection{Operaciones de Balanceo}
Los `giros` antes mencionados están definidos en las operaciones de balanceo, se tienen dos de estas, una para los subárboles izquierdos y otra para los 
derechos. Estas operaciones de balanceo, se muestran en seguida, se encargan de solucionar los casos en los que después de agregar una hoja quedan dos nodos rojos.
El giro elimina el doble nodo rojo al crear solo un nodo rojo con dos hijos negros, de igual manera al tener dos hijos negros nos aseguramos que el árbol crece de manera controlada 
en n\'umero de nodos negros, ya que en ningún momento se están agregando dos nodos negros contiguos. Cabe mencionar que esta es la única operación en donde se agregan nodos negros con la excepción de $makeBlack$, la cual describiremos mas adelante.
\begin{minted}{coq}
Definition lbal {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match l with
 | T R (T R a x b) y c => T R (T B a x b) y (T B c k r)
 | T R a x (T R b y c) => T R (T B a x b) y (T B c k r)
 | _ => T B l k r
 end.

 Definition rbal {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R (T R b y c) z d => T R (T B l k b) y (T B c z d)
 | T R b y (T R c z d) => T R (T B l k b) y (T B c z d)
 | _ => T B l k r
 end.
\end{minted}

Mas adelante se explicar\'a porque solamente nos estamos fijando en estos casos para el balanceo de los arboles.
\subsection {Funci\'on de inserci\'on}
Con esta funci\'on es donde por fin se puede apreciar que bibliotecas de Haskell se están usando, podemos apreciar como los tipos que estamos
agregando al \'arbol son tipos ordenados de la biblioteca Base de \textbf{GHC} y por esa misma manera estamos usando las comparaciones de esa misma biblioteca.

Se puede ver que la operación de balanceo solo se efectúa cuando el nodo por el que se pasa es negro, al ser estos los nodos que se cuentan para decidir si un \'arbol
esta balanceado. Al aplicar las operaciones de balanceo en estos nodos, nos aseguramos de no agregar nodos negros de mas, ya que si se agrega un nodo negro, se `baja` al subárbol hermano
el nodo negro del que se empez\'o a efectuar la operación de balanceo. 

Tengo que explicar esto con dibujos.
\begin{minted}{coq}
Fixpoint ins {a} `{GHC.Base.Ord a} (x:a) (s:RB a) :=
 match s with
 | E => T R E x E
 | T c l y r =>
    if x GHC.Base.< y : bool then 
      match c with
       | R => T R (ins x l) y r
       | B => lbal (ins x l) y r
      end
    else 
    if x GHC.Base.> y : bool then 
      match c with
       | R => T R l y (ins x r)
       | B => rbal l y (ins x r)
      end
    else s
 end.
\end{minted}

Esta función de inserción no cumple con una de las invariantes, que la raíz del árbol sea negra, en ciertos casos puede dejar la raíz roja y por eso se introduce las siguientes definiciones:

\begin{minted}{coq}
Definition makeBlack {a} `{GHC.Base.Ord a} (t:RB a) :=
 match t with
 | E => E
 | T _ a x b => T B a x b
 end.

Definition insert {a} `{GHC.Base.Ord a} (x:a) (s:RB a) := makeBlack (ins x s).
\end{minted}

La definici\'on makeBlack únicamente pinta cualquier nodo, y la definición insert corrige el detalle de la función ins al pintar de negro la raíz de árbol resultante de 
agregar un elemento a un \arn.

Estas funciones son suficientes para poder construir \arns que respeten las invariantes que se plantearon al principio. Se explicar\'a el proceso de la verificaci'on en el siguiente cap\'itulo.
\section{Eliminación de elementos en un \arn}
\begin{minted}{coq}
Definition rbal' {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R b y (T R c z d) => T R (T B l k b) y (T B c z d)
 | T R (T R b y c) z d => T R (T B l k b) y (T B c z d)
 | _ => T B l k r
 end.

Definition lbalS {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match l with
 | T R a x b => T R (T B a x b) k r
 | _ =>
   match r with
   | T B a y b => rbal' l k (T R a y b)
   | T R (T B a y b) z c => T R (T B l k a) y (rbal' b z (makeRed c))
   | _ => T R l k r 
   end
 end.

Definition rbalS {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R b y c => T R l k (T B b y c)
 | _ =>
   match l with
   | T B a x b => lbal (T R a x b) k r
   | T R a x (T B b y c) => T R (lbal (makeRed a) x b) y (T B c k r)
   | _ => T R l k r 
   end
 end.


Fixpoint append {a} `{GHC.Base.Ord a} (l:RB a) : RB a -> RB a :=
 match l with
 | E => fun r => r
 | T lc ll lx lr =>
   fix append_l (r:RB a) : RB a :=
   match r with
   | E => l
   | T rc rl rx rr =>
     match lc, rc with
     | R, R =>
       let lrl := append lr rl in
       match lrl with
       | T R lr' x rl' => T R (T R ll lx lr') x (T R rl' rx rr)
       | _ => T R ll lx (T R lrl rx rr)
       end
     | B, B =>
       let lrl := append lr rl in
       match lrl with
       | T R lr' x rl' => T R (T B ll lx lr') x (T B rl' rx rr)
       | _ => lbalS ll lx (T B lrl rx rr)
       end
     | B, R => T R (append_l rl) rx rr
     | R, B => T R ll lx (append lr r)
     end
   end
 end.


Fixpoint del {a} `{GHC.Base.Ord a} (x:a) (t:RB a) :=
 match t with
 | E => E
 | T _ a y b =>
    if x GHC.Base.< y : bool then 
      match a with
       | T B _ _ _ => lbalS (del x a) y b
       | _ => T R (del x a) y b
      end
    else 
    if x GHC.Base.> y : bool then 
      match b with
       | T B _ _ _ => rbalS a y (del x b)
       | _ => T R a y (del x b)
      end
    else append a b
 end.

Definition remove x t := makeBlack (del x t).
\end{minted}

\chapter{Verificación formal de \ARNs}
Los \ARNs son una estructura de datos que mejora el tiempo de acceso, de inserción o eliminación de
elementos con respecto a otras estructuras de datos, como las listas ligadas o doblemente ligadas. Como hemos visto en capítulos anteriores, para
poder alcanzar esta eficiencia los algoritmos usados en los \arns son complejos y complicados de
programar. Por esta razón es que nos preocupa que las implementaciones que realicemos sean correctas, es decir que todas las operaciones que realizamos con las
funciones antes descritas cumplan con las invariantes de los \arns.

\section{Capturando los invariantes de los \arns}
¿Como capturar las invariantes de los \arns? Utilizamos una definición inductiva, llamada $is\_redblack$
para poder capturar los invariantes, la cual lleva como parámetros un contador y un \'arbol. El contador
lleva el control de la cantidad de nodos negros mientras que el \'arbol es aquel que estamos buscando
verificar que cumpla con las invariantes de un \arn. Se muestra esta definici\`on a continuaci\'on:

\begin{minted}{coq}
Inductive is_redblack {a} `{GHC.Base.Ord a} : nat -> RB a -> Prop :=
 | RB_Leaf : is_redblack 0 E
 | RB_R n l k r : notred l -> notred r ->
                  is_redblack n l -> is_redblack n r ->
                  is_redblack n (T R l k r)
 | RB_B n l k r : is_redblack n l -> is_redblack n r ->
                  is_redblack (S n) (T B l k r).
\end{minted}

Esta definici\'on tiene tres casos; $RB\_Leaf$, $RB\_R$ y $RB\_B$. Desarrollando la idea de cada caso:
\begin{itemize}
        \item \textbf{RB\_Leaf} - el árbol vació es roji-negro.
        \item \textbf{RB\_R} - un árbol rojo donde lleves contados $n$ nodos negros, donde sus hijos sean \arns y no sean rojos.
        \item \textbf{RB\_B} - un árbol negro donde lleves contados $n+1$ nodos negros, incluido el actual, y sus hijos sean \arns.
\end{itemize}

Esta definici\'on captura los invariantes que estamos buscando, sin embargo no es suficiente para poder probar la correcci\'on de los \arns,
es demasiado restrictiva y costaría mucho trabajo poder demostrar solo con esta definici\'on. Por esta razón se agregan otras dos definiciones inductivas;
$nearly\_redblack$ y $redred\_tree$. 

\begin{minted}{coq}
Inductive redred_tree {a} `{GHC.Base.Ord a} (n:nat) : RB a -> Prop :=
 | RR_Rd l k r : is_redblack n l -> is_redblack n r -> redred_tree n (T R l k r).

Inductive nearly_redblack {a} `{GHC.Base.Ord a} (n:nat)(t:RB a) : Prop :=
 | ARB_RB : is_redblack n t -> nearly_redblack n t
 | ARB_RR : redred_tree n t -> nearly_redblack n t.
\end{minted}

Podemos notar que estas definiciones son versiones mas relajadas de $is\_redblack$. La definici\'on $nearly\_redblack$ permite que existan dos nodos rojos
en la ra\'iz del \'arbol, aprovech\'andose de $redred\_tree$, pues esta definici\'on es exactamente el caso $RB\_R$ pero sin las restricciones de que los sub\'arboles sean rojos, lo 
cual nos permite que hayan dos nodos rojos exactamente en la ra\'iz. Entonces un $nearly\_redblack$ es un \arn con la excepci\'on de que la ra\'iz puede ser roja. 

Finalmente, lo que se busca demostrar es que los \arns con las operaciones de inserci\'on y eliminaci\'on están dentro de la siguiente clase de arboles:

\begin{minted}{coq}
Class redblack {a} `{GHC.Base.Ord a} (t:RB a) := 
                            RedBlack : exists d, is_redblack d t.
\end{minted}

Lo que este enunciado esta diciendo es que un \arn es aquel que tiene una altura negra $d$ y cumple con las invariantes establecidas por la definici\'on 
$is\_redblack$.
\section{Verificación de la operación de inserción}

Para poder probar la inserci\'on se tienen que probar todas las variantes posibles que ofrecen las definiciones inductivas
que controlan los invariantes de los \arns, es decir, $is\_redblack$, $nearly\_redblack$ y $redred\_tree$.

Por esto es que la demostraci\'on se parte en dos lemas: $ins\_rr\_rb$, $ins\_arb$. Y en una instancia\cite{classes} de la clase $redblack$, $add\_rb$. Estos lemas los enunciaremos
y desarrollaremos la idea principal de la desmostraci\'on a continuaci\'on:

\subsection{Primer Lema}

\begin{minted}{coq}
Lemma ins_rr_rb {a} `{GHC.Base.Ord a} (x:a) (s: RB a) (n : nat) :
is_redblack n s -> ifred s (redred_tree n (ins x s)) (is_redblack n (ins x s)).
\end{minted}
 En este primer lema enunciamos lo siguiente: Si $s$ es un \arn bajo la definici\'on de $is\_redblack$, entonces 
 si $s$ es un \'arbol rojo, insertar un elemento $x$ en $s$ resulta en un \'arbol bajo la definci\'on de 
 $redred\_tree$, en otro caso entra en la definici\'on de $is\_redblack$.

 En otras palabras lo que este enunciado quiere decirnos es que si tenemos un \arn y agregamos un elemento a ese \'arbol
 el resultado puede tener ra\'iz roja, e incluso puede tener dos nodos rojos, uno en la ra\'iz y otro en cualquiera de los dos
 (o en los dos) nodos que siguen.

 La demostraci\'on de este lema comienza con una inducci\'on sobre el antecedente del lema, lo cual resulta en tres casos:
 \begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
______________________________________(1/3)
ifred E (redred_tree 0 (ins x E)) (is_redblack 0 (ins x E))
______________________________________(2/3)
ifred (T R l k r) (redred_tree n (ins x (T R l k r))) 
                  (is_redblack n (ins x (T R l k r)))
______________________________________(3/3)
ifred (T B l k r) (redred_tree (S n) (ins x (T B l k r)))
                  (is_redblack (S n) (ins x (T B l k r)))
 \end{minted}

 La funci\'on $ifred$ que se usa en este lema es una funci\'on auxiliar que b\'asicamente lo que nos ayuda hacer es decidir si un \'arbol es 
 rojo o no. 

 En el primero de estos casos notamos que su soluci\'on se da simplificando las funciones y resulta en uno de los casos
 de $is\_redblack$ ya que el \'arbol vacio no es rojo y la simplificaci\'on de $(ins(x,E))$ resulta en un \'arbol rojo con un elemento,
 esto por definici\'on de $ins$.

 Los dos casos tienen que ver con los colores del \'arbol, en el segundo el \'arbol es rojo y en el tercero es negro.
 Analicemos el segundo caso; como el \'arbol es rojo, entra al primer caso, es decir, entra al caso de la definici\'on $redred\_tree$,
 lo cual quiere decir que al insertar un elemento al \'arbol rojo, sin tener conocimiento de como son los subarboles de este, puede
 resultar en un \'arbol con uno o dos nodos rojos consecutivos en la ra\'iz de este, ya que cuando se tiene $ins$ en un nodo rojo, la operaci\'on de 
 balanceo no se lleva acabo, lo cual respeta la definici\'on de $redred\_tree$.

 El tercer caso describe el caso sobrante, el caso del \'arbol negro, este caso se complica un poco mas que el anterior, ya que al 
 agregar un nodo nuevo, se aplica una operaci\'on de balanceo y si en la siguiente llamada recursiva de $ins$ se vuelve a aplicar una operaci\'on 
 de balanceo, esta resultaria en un $redred\_tree$. En otro caso si no se realiza la llamada de balanceo en la siguiente llamada recursiva, es decir, si al siguiente nodo al que se le aplica la funci\'on es rojo, la definicion de $is\_redblack$ se sostiene.
\subsection{Segundo Lema}
\begin{minted}{coq}
Lemma ins_arb {a} `{GHC.Base.Ord a} (x:a) (s:RB a) (n:nat) : 
is_redblack n s -> nearly_redblack n (ins x s).
\end{minted}
En este segundo lema enuncia lo que hemos estado diciendo desde que se presento la funci\'on $ins$: La funci\'on $ins$ no garantiza que el \'arbol 
resultante sea un \arn. La demostraci\'on comienza introduciendo los antecedentes a las hipótesis y aplicando el lema anterior a la hip\'otesis:
\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : ifred s (redred_tree n (ins x s)) (is_redblack n (ins x s))
______________________________________(1/1)
nearly_redblack n (ins x s)
\end{minted}
Como no sabemos si el \'arbol $s$ es rojo o negro, tenemos que probar los dos casos, lo cual resulta en tener que probar si el resultado de insertar un elemento
es $redred\_tree$ o $is\_redblack$ y por definici\'on  de $nearly\_redblack$ podemos probar los dos casos.
\subsection{Instancia de agregaci\'on}
\begin{minted}{coq}
Instance add_rb {a} `{GHC.Base.Ord a} (x:a) (s: RB a) : redblack s -> redblack (insert x s).
\end{minted}
Para poder crear la instancia de la clase $redblack$ es necesario usar la envoltura $insert$ para la funci\'on $ins$. Esta envoltura lo que hace es pintar el \'arbol resultante de la funci\'on $ins$ de color negro. De esta manera podemos asegurar que el \'arbol resultante ya no es entra en la definici\'on de $nearly\_redblack$.
\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : is_redblack n s
______________________________________(1/1)
redblack (makeBlack (ins x s))
\end{minted}
Entonces como dijimos anteriormente, sabemos que $(ins(x,s))$ es un $nearly\_redblack$, y al aplicar el lema pasado a este termino nos da como resultado la hipotesis $H1$ y la instancia queda definida.

Ahora podemos decir que esta implementaci\'on de la funci\'on de inserci\'on es correcta y completa bajo las invariantes establecidas en las definici\'on inductiva $is_redblack$. La operaci\'on ha sido verificada formalmente, ahora continuaremos con la funci\'on de eliminaci\'on.  
\section{Verificación de la operación de eliminación}
\begin{minted}{coq}
Lemma append_arb_rb {a} `{GHC.Base.Ord a} (n:nat) (l r: RB a) : 
  is_redblack n l -> is_redblack n r ->
   (nearly_redblack n (append l r)) /\
   (notred l -> notred r -> is_redblack n (append l r)).


Lemma del_arb {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
 with del_rb  {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack n s -> notblack s -> is_redblack n (del x s).

Instance remove_rb s x : redblack s -> redblack (remove x s).
\end{minted}
\chapter{Conclusiones}  
%aprendiendo a usar esta cosa, it is cool-aid
\bibliographystyle{plain} % We choose the "plain" reference style
\bibliography{refs} % Entries are in the "refs.bib" file
\backmatter%@sglvgdor


\end{document}
