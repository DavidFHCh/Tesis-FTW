\documentclass[letterpaper,12pt,oneside]{book}
\usepackage[top=1in, left=0.9in, right=1.25in, bottom=1in]{geometry}
\usepackage{bachelorstitlepageUNAM}
\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{graphicx}
\usepackage{tikz} 
\usepackage{tocloft}
\graphicspath{{./figs/}}
\usepackage{setspace}
\usepackage{minted}
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}

\newcommand{\coq}{\textbf{Coq}}
\newcommand{\Arns}{Arboles Roji-negros}
\newcommand{\Arn}{Árbol Roji-negro}
\newcommand{\arn}{árbol roji-negro}
\newcommand{\arns}{arboles roji-negros}
%\usepackage[round]{natbib}

%para pintar arboles bonitos...
\usepackage{tikz}
\usetikzlibrary{arrows}
%\usetikzlibrary{arrows}


\tikzset{
treenode/.style = {align=center, inner sep=0pt, text centered,
font=\sffamily},
arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
fill=black, text width=1.5em},% arbre rouge noir, noeud noir
arn_r/.style = {treenode, circle, white, draw=red, fill= red,
text width=1.5em, very thick},% arbre rouge noir, noeud rouge
arn_x/.style = {treenode, rectangle, white, draw=black, fill= black,
minimum width=0.5em, minimum height=0.5em},% arbre rouge noir, nil
arn_bb/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=gray,
fill=gray, text width=1.5em},
arn_nb/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
fill=white, text width=1.5em},
arn_w/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=brown,
fill=brown, text width=1.5em},
arn_xb/.style = {treenode, rectangle, white, draw=gray, fill= gray,
minimum width=0.5em, minimum height=0.5em}
}

\renewcommand\cftsecpresnum{\S}
\renewcommand\cftsubsecpresnum{\S}   

\theoremstyle{plain}
\newtheorem{thm}{Teorema}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposici\'on}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definci\'on}[section]
\newtheorem{exmp}{Ejemplo}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}


\begin{document}
%------------------------------

\begin{titlepage}
\thispagestyle{empty}
\begin{minipage}[c][0.17\textheight][c]{0.25\textwidth}
\begin{center}
\includegraphics[width=3.5cm, height=3.5cm]{Escudo-UNAM.pdf}
\end{center}
\end{minipage}
\begin{minipage}[c][0.195\textheight][t]{0.75\textwidth}
\begin{center}
\vspace{0.3cm}
\textsc{\large Universidad Nacional Aut\'onoma de M\'exico}\\[0.5cm]
\vspace{0.3cm}
\hrule height2.5pt
\vspace{.2cm}
\hrule height1pt
\vspace{.8cm}
\textsc{Facultad de Ciencias}\\[0.5cm] %
\end{center}
\end{minipage}

\begin{minipage}[c][0.81\textheight][t]{0.25\textwidth}
\vspace*{5mm}
\begin{center}
\hskip2.0mm
\vrule width1pt height13cm 
\vspace{5mm}
\hskip2pt
\vrule width2.5pt height13cm
\hskip2pt
\vrule width1pt height13cm \\
\vspace{5mm}
\includegraphics[height=4.0cm]{Escudo-FCIENCIAS.pdf}
\end{center}
\end{minipage}
\begin{minipage}[c][0.81\textheight][t]{0.75\textwidth}
\begin{center}
\vspace{1cm}

{\large\scshape Verificación formal de arboles roji-negros}\\[.2in]

\vspace{2cm}            

\textsc{\LARGE T\hspace{1.5cm}E\hspace{1.5cm}S\hspace{1.5cm}I\hspace{1.5cm}S}\\[0.5cm]
\textsc{\large que para obtener el t\'itulo de:}\\[0.5cm]
\textsc{\large Licenciado en Ciencias de la Computación}\\[0.5cm]
\textsc{\large presenta:}\\[0.5cm]
\textsc{\large {David Felipe Hern\'andez Chiapa}}\\[2cm]          

\vspace{0.5cm}

{\large\scshape Tutores:\\[0.3cm] {Dra. Lourdes del Carmen Gonzalez Huesca}}\\[.2in]

\vspace{0.5cm}

\large{Ciudad Universitaria, Ciudad de México,}{ }{2019}
\end{center}
\end{minipage}
\end{titlepage}



%---------------------------------
\frontmatter
%\maketitle
\chapter*{}
\begin{flushright}%
\emph{Dedicatoria ...}
\thispagestyle{empty}
\end{flushright}

\chapter{Agradecimientos}
\spacing{1.5}%\doublespacing

\tableofcontents
\listoffigures


\mainmatter

\chapter{Introducción} 
\section{Motivación}
\section{Arboles Roji-negros}
Los {{{{\arn}}}s} son una estructura de datos donde las operaciones de inserci\'on, eliminaci\'on y búsqueda se efectúan
en tiempo logarítmico, es decir, la complejidad de esas operaciones es $O(log(n))$, estos son una subclase de los
arboles binarios de búsqueda, en los cuales la complejidad de dichas operaciones crece hasta $O(n)$. Esta mejora en la complejidad se obtiene 
gracias a la introducción de colores a los nodos del \'arbol y a invariantes relacionados con estos colores, las cuales describiremos 
mas adelante.
\subsection{Definici\'on de {{{{\arn}}}s}}
Un {{{\arn}}} se define de la siguiente manera:
\begin{defn}
Un \'arbol binario de búsqueda es un {{{\arn}}} si satisface lo siguiente:
\begin{enumerate}
    \item Todos sus nodos son rojos o negros.
    \item El \'arbol vació es negro.
    \item La raíz es negra.
    \item Las siguientes invariantes se tienen que cumplir:
    \begin{itemize}
        \item Un nodo rojo debe tener hijos negros.
        \item Todos los caminos de la raíz a las hojas deben tener la misma cantidad de nodos negros.
    \end{itemize}
\end{enumerate}
\end{defn}
Se presentan en la Figura 1, ejemplos de {\arns}. Se muestran dos variantes, uno con nodos vacíos en las hojas
y el otro sin estos.


\begin{figure}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;
\draw node [text width=7cm] at (-1,-4.5)
{
\'Arbol roji-negro con vac\'ios.
}
;
\node [arn_n] at (5,0) {6}
    child{ node [arn_r] {2} 
        child{ node [arn_n] {1}}
        child{ node [arn_n] {4}
            child{ node [arn_r] {3}}
            child{ node [arn_r] {5}}
        }                            
    }
    child{ node [arn_n] {8}
        child{ node [arn_r] {9}}
    }
;
\draw node [text width=7cm] at (7,-4.5)
{
\'Arbol roji-negro.
}
;
\end{tikzpicture}
\centering Figura 1.
\end{figure}
Nos interesa estudiar este tipo no trivial de arboles binarios de búsqueda para poder
demostrar la correcci'on de estos usando el asistente de pruebas {\coq} y así poder mostrar las ventajas, y problemáticas de este proceso.
\section{Traducción de Haskell a {\coq} (hs-to-coq)}

\section {Sobre este trabajo}
El contenido, demostraciones de este trabajo se encuentran almacenados en ...bla.... Aqu\'i se presentan 
definiciones, lemas y clases sin incluir las demostraciones en {\coq}, es decir, los scripts de prueba. En su 
lugar se describen de forma informal las demostraciones para poder entender en alto nivel la estructura de la 
verificaci\'on formal realizada.

\chapter{Implementación de arboles roji-negros en {\coq}}
\section{Traducción de implementaciones}
Se tuvieron varias aproximaciones para la implementación de {{{{\arn}}}s}; la primera fue obtener las implementaciones en
Haskell de estos\cite{tesisG} y pasar estas implementaciones como entrada a hs-to-coq, la 
segunda aproximación, y la que se uso para esta tesis, fue obtener la implementación de Okasaki traducida a Coq 
\cite{MSetRBT}, con la diferencia de que se usaron las bibliotecas de Haskell que contienen los tipos y
comparaciones, estas obtenidas de la traducción de estas bibliotecas a Coq, en lugar de usar las 
bibliotecas ya existentes de Coq.
A continuación profundizaremos acerca de estos dos métodos.
\subsection{Traducción directa de implementaciones de Haskell a Coq}
De un trabajo anterior\cite{tesisG} se obtuvieron diversas implementaciones de {\arns} la mayor parte de estas
cambiaba principalmente en las implementaciones de las operaciones de borrado, siendo esta la operación mas compleja. 
Estas diversas implementaciones van desde la implementación de Okasaki\footnote{siendo esta la m\'as simple}, constructores inteligentes\footnote{implementaci\'on anterior con optimizaciones} y tipos anidados\footnote{una implementaci\'on totalmente diferente a las anteriores}.

Por la compleja naturaleza de estas implementaciones\footnote{incluso Okasaki} la traducción manual del código de Haskell resulto ser muy problemática,
esto porque las implementaciones en Haskell se aprovechan del hecho de que en este lenguaje se pueden dar funciones parciales, 
lo cual resulta problemático cuando se quiere traducir a Coq, ya que este lenguaje únicamente acepta funciones totales.

Por lo expuesto anteriormente se opto por usar la herramienta \textbf{hs-to-coq} para facilitar la traducci\'on, pero por las mismas razones antes descritas\footnote{las funciones no eran totales},
la herramienta caia en alguna de estas dos situaciones:

\begin{itemize}
    \item El tiempo de ejecuci\'on de la herramienta era muy alto y eventualmente los recursos de la maquina virtual, donde esta herramienta se ejecuto, se quedaba sin recursos\footnote{en especial memoria}.
    \item La herramienta generaba c\'odigo en Coq pero con elementos de Haskell cuyas bibliotecas todavía no habían sido traducidas del todo.
\end{itemize}{}

Se busco otra acercamiento para poder verificar esta estructura; la herramienta hs-to-coq tiene parte de las bibliotecas de Haskell 
traducidas a Coq, entonces se uso la implementación de {\arns} de las bibliotecas de {\coq}\cite{MSetRBT} pero usando los tipos y comparaciones de tipos de Haskell traducidos a Coq.


\section{Inserción de elementos en un {{{\arn}}}}

La inserci\'on de elementos a un {{{\arn}}} es la operaci\'on mas sencilla de de las dos operaciones que se verificaran en este trabajo. La idea principal detrás de este algoritmo es que 
solo se agreguen hojas al \'arbol binario y se efectúen ``giros'' para mantener las invariantes de la estructura.
\subsection{Operaciones de Balanceo}
Los ``giros'' antes mencionados están definidos en las operaciones de balanceo, se tienen dos, una operaci\'on para los subárboles izquierdos y otra para los 
derechos. Estas operaciones de balanceo, se muestra el c\'odigo en seguida, se encargan de solucionar los
casos en los que inmediatamente después de agregar una hoja, los invariantes son violados, por ejemplo, 
dos nodos rojos que resultan contiguos en algún lugar de la estructura del \'arbol. De hecho solo dos de 
los tres invariantes pueden ser violados cuando se agrega un nuevo nodo, siendo estos que hayan dos nodos
rojos contiguos o que la raíz del árbol resulte roja\footnote{esto no se arregla con giros, si no, pintando la raíz de negro después de insertar}.

El giro elimina el doble nodo rojo, al crear solo un nodo rojo con dos hijos negros, de igual manera al tener dos hijos negros nos aseguramos que el árbol crece de manera controlada 
en n\'umero de nodos negros\footnote{este n\'umero de nodos negros se conoce como altura negra}, ya que en ningún momento se están agregando dos nodos negros contiguos. Cabe mencionar que esta es la única operación en donde se agregan nodos negros con la excepción de $makeBlack$, la cual describiremos mas adelante.
\begin{minted}{coq}
Definition lbal {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match l with
 | T R (T R a x b) y c => T R (T B a x b) y (T B c k r)
 | T R a x (T R b y c) => T R (T B a x b) y (T B c k r)
 | _ => T B l k r
 end.

 Definition rbal {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R (T R b y c) z d => T R (T B l k b) y (T B c z d)
 | T R b y (T R c z d) => T R (T B l k b) y (T B c z d)
 | _ => T B l k r
 end.
\end{minted}

Mas adelante se explicar\'a porque solamente nos concentramos en estos cuatro casos y porque la mayor parte de los casos se reacomodan en un \'arbol con ra\'iz negra.
\subsection {Funci\'on de inserci\'on}
Con esta funci\'on es donde por primera vez podemos apreciar el uso de las  bibliotecas de Haskell, podemos apreciar como los tipos que estamos
agregando al \'arbol son tipos ordenados de la biblioteca $Base$ de \textbf{GHC} y por esa misma raz\'on estamos usando las comparaciones de esa biblioteca.

\begin{minted}{coq}
Fixpoint ins {a} `{GHC.Base.Ord a} (x:a) (s:RB a) :=
 match s with
 | E => T R E x E
 | T c l y r =>
    if x GHC.Base.< y : bool then 
      match c with
       | R => T R (ins x l) y r
       | B => lbal (ins x l) y r
      end
    else 
    if x GHC.Base.> y : bool then 
      match c with
       | R => T R l y (ins x r)
       | B => rbal l y (ins x r)
      end
    else s
 end.
\end{minted}

Leyendo mas detenidamente la funci\'on se puede observar que las operaciones de balanceo solo se efectúan
cuando el nodo por el que se esta pasando es negro, esto sucede por la raz'on de que estos son los nodos 
que se toman en cuenta para decidir si un \'arbol esta balanceado. Al aplicar las operaciones de balanceo
en estos nodos, nos aseguramos de no quedar con nodos negros de mas en alguno de los hijos del nodo al 
que se le esta aplicando la operación de balanceo. Esto se puede apreciar si nos regresamos a las 
definiciones de las operaciones de balanceo, tomemos $rbal$\footnote{Con $lbal$ la idea es an\'aloga}, tenemos dos casos:

\begin{itemize}
    \item Sean $x$, $y$ y $z$ nodos del \'arbol y sea $n$ un subárbol, $x$ es el nodo al que se le aplica
    la operaci\'on de balanceo, $n$ es el subárbol izquierdo, $y$ es el nodo derecho  de $x$ y $z$ es hijo de
    $y$. Suponiendo que $y$ y $z$ son rojos\footnote{se viola una invariante, dos nodos rojos contiguos},
    se cae en cualquiera de los dos casos de $rbal$ que no son el caso general. En este momento es donde
    se efectúa el ``giro'' del árbol y resulta lo siguiente: $x$ se vuelve el hijo izquierdo de $y$ y $z$ se pinta de negro.
    
    En el momento en que $x$ se convierte en hijo izquierdo de $y$ el \'arbol se desbalancea, es por esto que se pinta de negro a $z$, así los dos nodos negros son hijos de $y$ y la invariante se conserva.
    \item En cualquier otro caso el \'arbol no sufre modificaci\'on alguna.
\end{itemize}{}

Esta función de inserción puede no cumplir con una de las invariantes, que la raíz del árbol sea negra, es por esto que se introducen las siguientes definiciones:

\begin{minted}{coq}
Definition makeBlack {a} `{GHC.Base.Ord a} (t:RB a) :=
 match t with
 | E => E
 | T _ a x b => T B a x b
 end.

Definition insert {a} `{GHC.Base.Ord a} (x:a) (s:RB a) := makeBlack (ins x s).
\end{minted}

La definici\'on $makeBlack$ únicamente pinta cualquier nodo de color negro y la definición $insert$ es una envoltura que corrige el detalle de la función $ins$\footnote{raiz roja} al pintar de negro la raíz de árbol resultante de insertar un elemento a un {\arn}.

Estas funciones son suficientes para poder construir {\arns} que respeten las invariantes que se plantearon al principio. Se explicar\'a el proceso de la verificaci'on en el siguiente cap\'itulo.
\section{Eliminación de elementos en un {\arn}}
\begin{minted}{coq}
Definition rbal' {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R b y (T R c z d) => T R (T B l k b) y (T B c z d)
 | T R (T R b y c) z d => T R (T B l k b) y (T B c z d)
 | _ => T B l k r
 end.

Definition lbalS {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match l with
 | T R a x b => T R (T B a x b) k r
 | _ =>
   match r with
   | T B a y b => rbal' l k (T R a y b)
   | T R (T B a y b) z c => T R (T B l k a) y (rbal' b z (makeRed c))
   | _ => T R l k r 
   end
 end.

Definition rbalS {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R b y c => T R l k (T B b y c)
 | _ =>
   match l with
   | T B a x b => lbal (T R a x b) k r
   | T R a x (T B b y c) => T R (lbal (makeRed a) x b) y (T B c k r)
   | _ => T R l k r 
   end
 end.


Fixpoint append {a} `{GHC.Base.Ord a} (l:RB a) : RB a -> RB a :=
 match l with
 | E => fun r => r
 | T lc ll lx lr =>
   fix append_l (r:RB a) : RB a :=
   match r with
   | E => l
   | T rc rl rx rr =>
     match lc, rc with
     | R, R =>
       let lrl := append lr rl in
       match lrl with
       | T R lr' x rl' => T R (T R ll lx lr') x (T R rl' rx rr)
       | _ => T R ll lx (T R lrl rx rr)
       end
     | B, B =>
       let lrl := append lr rl in
       match lrl with
       | T R lr' x rl' => T R (T B ll lx lr') x (T B rl' rx rr)
       | _ => lbalS ll lx (T B lrl rx rr)
       end
     | B, R => T R (append_l rl) rx rr
     | R, B => T R ll lx (append lr r)
     end
   end
 end.


Fixpoint del {a} `{GHC.Base.Ord a} (x:a) (t:RB a) :=
 match t with
 | E => E
 | T _ a y b =>
    if x GHC.Base.< y : bool then 
      match a with
       | T B _ _ _ => lbalS (del x a) y b
       | _ => T R (del x a) y b
      end
    else 
    if x GHC.Base.> y : bool then 
      match b with
       | T B _ _ _ => rbalS a y (del x b)
       | _ => T R a y (del x b)
      end
    else append a b
 end.

Definition remove x t := makeBlack (del x t).
\end{minted}

\chapter{Verificación formal de {{{{\arn}}}s}}
Los {{{{\arn}}}s} son una estructura de datos que mejora el tiempo de acceso, de inserción o eliminación de
elementos con respecto a otras estructuras de datos, como las listas ligadas o doblemente ligadas. Como hemos visto en capítulos anteriores, para
poder alcanzar esta eficiencia los algoritmos usados en los {{{{\arn}}}s} son complejos y complicados de
programar. Por esta razón es que nos preocupa que las implementaciones que realicemos sean correctas, es decir que todas las operaciones que realizamos con las
funciones antes descritas cumplan con las invariantes de los {{{{\arn}}}s}.
\section{Capturando los invariantes de los {\ARNs}}
Una de las partes mas importantes de la verificaci\'on formal de cualquier estructura de datos es la captura de sus invariantes,
es decir, poder escribir una o varias definiciones inductivas que describan a la estructura de datos utilizando las invariantes. Después, con estas definiciones es que se enuncian los lemas, clases y posteriormente instancias de estas. 

A continuaci\'on se describen dos de los conjuntos de definiciones inductivas, muy similares entre ellas, para poder verificar formalmente esta estructura de datos. La primera es un primer intento que es insuficiente ya que los tipos inductivos y los principios de demostraci\'on no son los \'optimos. El segundo intento es un conjunto de definiciones inductivas que tienen mas detalle para describir los invariantes. Estas definiciones est\'an relacionadas con las propiedades de las operaciones de inserci\'on y eliminaci\'on. 

\subsection{Primer Conjunto de Definiciones Inductivas}
Los dos conjuntos de definiciones inductivas comparten la misma idea; una definici\'on que describa lo que es un {{{\arn}}} y otra definici\'on mas relajada de la misma.

La primera definici'on se llama $isRb$ y esta definida de la siguiente manera: 
\begin{minted}{coq}
Inductive isRB : Tree -> color -> nat -> Prop :=
 | IsRB_leaf: forall c, isRB E c 0
 | IsRB_r: forall tl k kv tr n,
          isRB tl Red n ->
          isRB tr Red n ->
          isRB (T Red tl k kv tr) Black n
 | IsRB_b: forall c tl k kv tr n,
          isRB tl Black n ->
          isRB tr Black n ->
          isRB (T Black tl k kv tr) c (S n).
\end{minted}
Esta definici\'on tiene tres casos
\begin{itemize}
        \item \textbf{IsRB\_Leaf} - el árbol vacío con altura 0 es roji-negro.
        \item \textbf{IsRB\_r} - un árbol rojo con altura negra $n$ y color negro, con hijos roji-negros con color rojo y altura $n$.
        \item \textbf{IsRB\_b} - un árbol negro con altura negra $n+1$ y cualquier color, con hijos roji-negros con altura $n$ y color negro.  
\end{itemize}

Con estos casos se puede asegurar que las invariantes no se violan, ya que si se tiene un nodo rojo forzosamente se cae en el caso de $IsRB\_r$
y es requerido que el color que se le pase a la definici\'on sea negro, porque esto indica que el siguiente nodo \textbf{tiene} que ser negro. 
En otro caso si se tiene un nodo negro, al poderle pasar cualquier color a la definici\'on, se refiere a que después de un nodo negro
puede existir un nodo rojo o negro. Al llevar el conteo de negros nos aseguramos de que los subarboles tengan la misma altura negra y de esta manera
asegurar el balanceo de el \'arbol que se esta analizando con la definici\'on.


La segunda definici\'on, $nearRB$,  permite mas flexibilidad en el \'arbol, podemos verla a continuaci\'on: 
\begin{minted}{coq}
Inductive nearRB : Tree -> nat -> Prop :=
| nrRB_r: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Red tl k kv tr) n
| nrRB_b: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Black tl k kv tr) (S n).
\end{minted}
Se aprecia que solo se tienen dos casos y no se tiene un argumento para un color, sin embargo, a diferencia de $isRB$ esta no se
llama recursivamente y llama a $isRb$ inmediatamente, además podemos ver que ambas definiciones comparten el contador de nodos negros.
Entonces el hecho de que se haya retirado el argumento de color de esta definici\'on permite una cosa: Que en la ra\'iz del \'arbol 
puedan haber a lo mas dos nodos rojos contiguos.

\subsubsection{Intento de Verificaci\'on}
Se realiz\'o un intento fallido de verificac\'on de la operaci\'on de inserci\'on, tal y como se muestra en \cite{appel}, pero se encontró un
problema de falta de hipótesis para poder probar una meta, probablemente por mala elección de estilo de demostraci\'on, implementaci\'on o las definiciones 
inductivas mostradas anteriormente. Se noto que el hecho de que toda la informaci\'on referente a los invariantes estuviera codificada en las definiciones,
sin uso de 'definiciones auxiliares', complica demasiado la verificaci\'on. Se llego a esta conclusi\'on ya queel caso 'sencillo' de la verificaci\'on de
{{{{\arn}}}s} es la inserci\'on y esta se complico mucho la misma.

\subsection{Segundo Conjunto de Definiciones Inductivas}

Entonces, ¿como capturar las invariantes de los \'arboles roji-nergos y al mismo tiempo facilitar la verificaci\'on? 
Utilizamos una definición inductiva, llamada $is\_redblack$
para poder capturar los invariantes, la cual lleva como parámetros un contador y un \'arbol. El contador
lleva el control de la cantidad de nodos negros, es decir la altura negra del nodo, mientras que el \'arbol es aquel que estamos buscando
verificar que cumpla con las invariantes de un {\arn}. Se muestra esta definici\`on a continuaci\'on:

\begin{minted}{coq}
Inductive is_redblack {a} `{GHC.Base.Ord a} : nat -> RB a -> Prop :=
 | RB_Leaf : is_redblack 0 E
 | RB_R n l k r : notred l -> notred r ->
                  is_redblack n l -> is_redblack n r ->
                  is_redblack n (T R l k r)
 | RB_B n l k r : is_redblack n l -> is_redblack n r ->
                  is_redblack (S n) (T B l k r).
\end{minted}

Esta definici\'on tiene tres casos; $RB\_Leaf$, $RB\_R$ y $RB\_B$. Desarrollando la idea de cada caso:
\begin{itemize}
        \item \textbf{RB\_Leaf} - el árbol vació es roji-negro.
        \item \textbf{RB\_R} - un árbol rojo donde lleves contados $n$ nodos negros, donde sus hijos sean {\arns} y no sean rojos.
        \item \textbf{RB\_B} - un árbol negro donde lleves contados $n+1$ nodos negros, incluido el actual, y sus hijos sean {{{{\arn}}}s}.
\end{itemize}

Esta definici\'on captura los invariantes que estamos buscando, sin embargo no es suficiente para poder probar la correcci\'on de los {{{{\arn}}}s},
es demasiado restrictiva y costaría mucho trabajo poder demostrar solo con esta definici\'on. Por esta razón se agregan otras dos definiciones inductivas; $redred\_tree$ y $nearly\_redblack$. 

\begin{minted}{coq}
Inductive redred_tree {a} `{GHC.Base.Ord a} (n:nat) : RB a -> Prop :=
 | RR_Rd l k r : is_redblack n l -> is_redblack n r -> redred_tree n (T R l k r).

Inductive nearly_redblack {a} `{GHC.Base.Ord a} (n:nat)(t:RB a) : Prop :=
 | ARB_RB : is_redblack n t -> nearly_redblack n t
 | ARB_RR : redred_tree n t -> nearly_redblack n t.
\end{minted}

Podemos notar que estas definiciones son versiones mas relajadas de $is\_redblack$. La definici\'on $nearly\_redblack$ permite que existan dos nodos rojos
en la ra\'iz del \'arbol, aprovech\'andose de $redred\_tree$, pues esta definici\'on es exactamente el caso $RB\_R$ pero sin las restricciones de que los sub\'arboles sean rojos, lo 
cual nos permite que hayan dos nodos rojos exactamente en la ra\'iz. Entonces un $nearly\_redblack$ es un {{{\arn}}} con la excepci\'on de que la ra\'iz puede ser roja. 

Finalmente, lo que se busca demostrar es que los {{{{\arn}}}s} con las operaciones de inserci\'on y eliminaci\'on están dentro de la siguiente clase de arboles:

\begin{minted}{coq}
Class redblack {a} `{GHC.Base.Ord a} (t:RB a) := 
                            RedBlack : exists d, is_redblack d t.
\end{minted}

Lo que este enunciado esta diciendo es que un {{{\arn}}} es aquel que tiene una altura negra $d$ y cumple con las invariantes establecidas por la definici\'on 
$is\_redblack$.

\subsubsection{Segundo Intento de Verificaci\'on}
En contraste con el conjunto de de definiciones de la secci\'on pasada, se separa la definici\'on de $nearly\_redblack$ y se crea $redred\_tree$, además se crea la clase de {{{{\arn}}}s}, lo cual afina mas la definici\'on de un {{{\arn}}} y ayuda a la verificaci\'on, es por esto que se eligio este conjunto de definiciones, las cuales fueron obtenidas de \cite{MSetRBT}.
\section{Verificación de la operación de inserción}

Para poder probar la inserci\'on se tienen que probar todas las variantes posibles que ofrecen las definiciones inductivas
que controlan los invariantes de los {{{{\arn}}}s}, es decir, $is\_redblack$, $nearly\_redblack$ y $redred\_tree$.

Por esto es que la demostraci\'on se parte en dos lemas: $ins\_rr\_rb$, $ins\_arb$. Y en una instancia\cite{classes} de la clase $redblack$, $add\_rb$. Estos lemas los enunciaremos
y desarrollaremos la idea principal de la desmostraci\'on a continuaci\'on:

\subsection{Primer Lema}

\begin{minted}{coq}
Lemma ins_rr_rb {a} `{GHC.Base.Ord a} (x:a) (s: RB a) (n : nat) :
is_redblack n s -> ifred s (redred_tree n (ins x s)) (is_redblack n (ins x s)).
\end{minted}
 En este primer lema enunciamos lo siguiente: Si $s$ es un {{{\arn}}} bajo la definici\'on de $is\_redblack$, entonces 
 si $s$ es un \'arbol rojo, insertar un elemento $x$ en $s$ resulta en un \'arbol bajo la definci\'on de 
 $redred\_tree$, en otro caso entra en la definici\'on de $is\_redblack$.

 En otras palabras lo que este enunciado quiere decirnos es que si tenemos un {{{\arn}}} y agregamos un elemento a ese \'arbol
 el resultado puede tener ra\'iz roja, e incluso puede tener dos nodos rojos, uno en la ra\'iz y otro en cualquiera de los dos
 (o en los dos) nodos que siguen.

 La demostraci\'on de este lema comienza con una inducci\'on sobre el antecedente del lema, lo cual resulta en tres casos:
 \begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
______________________________________(1/3)
ifred E (redred_tree 0 (ins x E)) (is_redblack 0 (ins x E))
______________________________________(2/3)
ifred (T R l k r) (redred_tree n (ins x (T R l k r))) 
                  (is_redblack n (ins x (T R l k r)))
______________________________________(3/3)
ifred (T B l k r) (redred_tree (S n) (ins x (T B l k r)))
                  (is_redblack (S n) (ins x (T B l k r)))
 \end{minted}

 La funci\'on $ifred$ que se usa en este lema es una funci\'on auxiliar que b\'asicamente lo que nos ayuda hacer es decidir si un \'arbol es 
 rojo o no. 

 En el primero de estos casos notamos que su soluci\'on se da simplificando las funciones y resulta en uno de los casos
 de $is\_redblack$ ya que el \'arbol vacio no es rojo y la simplificaci\'on de $(ins(x,E))$ resulta en un \'arbol rojo con un elemento,
 esto por definici\'on de $ins$.

 Los dos casos tienen que ver con los colores del \'arbol, en el segundo el \'arbol es rojo y en el tercero es negro.
 Analicemos el segundo caso; como el \'arbol es rojo, entra al primer caso, es decir, entra al caso de la definici\'on $redred\_tree$,
 lo cual quiere decir que al insertar un elemento al \'arbol rojo, sin tener conocimiento de como son los subarboles de este, puede
 resultar en un \'arbol con uno o dos nodos rojos consecutivos en la ra\'iz de este, ya que cuando se tiene $ins$ en un nodo rojo, la operaci\'on de 
 balanceo no se lleva acabo, lo cual respeta la definici\'on de $redred\_tree$.

 El tercer caso describe el caso sobrante, el caso del \'arbol negro, este caso se complica un poco mas que el anterior, ya que al 
 agregar un nodo nuevo, se aplica una operaci\'on de balanceo y si en la siguiente llamada recursiva de $ins$ se vuelve a aplicar una operaci\'on 
 de balanceo, esta resultaria en un $redred\_tree$. En otro caso si no se realiza la llamada de balanceo en la siguiente llamada recursiva, es decir, si al siguiente nodo al que se le aplica la funci\'on es rojo, la definicion de $is\_redblack$ se sostiene.
\subsection{Segundo Lema}
\begin{minted}{coq}
Lemma ins_arb {a} `{GHC.Base.Ord a} (x:a) (s:RB a) (n:nat) : 
is_redblack n s -> nearly_redblack n (ins x s).
\end{minted}
En este segundo lema enuncia lo que hemos estado diciendo desde que se presento la funci\'on $ins$: La funci\'on $ins$ no garantiza que el \'arbol 
resultante sea un {{{\arn}}}. La demostraci\'on comienza introduciendo los antecedentes a las hipótesis y aplicando el lema anterior a la hip\'otesis:
\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : ifred s (redred_tree n (ins x s)) (is_redblack n (ins x s))
______________________________________(1/1)
nearly_redblack n (ins x s)
\end{minted}
Como no sabemos si el \'arbol $s$ es rojo o negro, tenemos que probar los dos casos, lo cual resulta en tener que probar si el resultado de insertar un elemento
es $redred\_tree$ o $is\_redblack$ y por definici\'on  de $nearly\_redblack$ podemos probar los dos casos.
\subsection{Instancia de la Funci\'on de Inserci\'on}
\begin{minted}{coq}
Instance add_rb {a} `{GHC.Base.Ord a} (x:a) (s: RB a) :
                                     redblack s -> redblack (insert x s).
\end{minted}
Para poder crear la instancia de la clase $redblack$ es necesario usar la envoltura $insert$ para la funci\'on $ins$. Esta envoltura lo que hace es pintar el \'arbol resultante de la funci\'on $ins$ de color negro. De esta manera podemos asegurar que el \'arbol resultante ya no entra en la definici\'on de $nearly\_redblack$.
\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : is_redblack n s
______________________________________(1/1)
redblack (makeBlack (ins x s))
\end{minted}
Entonces como dijimos anteriormente, sabemos que $(ins(x,s))$ es un $nearly\_redblack$, y al aplicar el lema pasado a este termino nos da como resultado la hipotesis $H1$ y la instancia queda definida.

Ahora podemos decir que esta implementaci\'on de la funci\'on de inserci\'on es correcta y completa bajo las invariantes establecidas en las definici\'on inductiva $is_redblack$. La operaci\'on ha sido verificada formalmente, ahora continuaremos con la funci\'on de eliminaci\'on.  
\section{Verificación de la operación de eliminación}
\begin{minted}{coq}
Lemma append_arb_rb {a} `{GHC.Base.Ord a} (n:nat) (l r: RB a) : 
  is_redblack n l -> is_redblack n r ->
   (nearly_redblack n (append l r)) /\
   (notred l -> notred r -> is_redblack n (append l r)).


Lemma del_arb {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
 with del_rb  {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack n s -> notblack s -> is_redblack n (del x s).

Instance remove_rb s x : redblack s -> redblack (remove x s).
\end{minted}
\chapter{Conclusiones}  
%aprendiendo a usar esta cosa, it is cool-aid
\bibliographystyle{plain} % We choose the "plain" reference style
\bibliography{refs} % Entries are in the "refs.bib" file
\backmatter%@sglvgdor


\end{document}
