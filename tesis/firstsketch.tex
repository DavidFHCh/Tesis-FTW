\documentclass[letterpaper,12pt,oneside]{book}
\usepackage[top=1in, left=0.9in, right=1.25in, bottom=1in]{geometry}
\usepackage{bachelorstitlepageUNAM}
\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{graphicx}
\usepackage{tikz} 
\usepackage{tocloft}
\graphicspath{{./figs/}}
\usepackage{setspace}
\usepackage{minted}
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}
\usepackage{caption}

\newcommand{\coq}{\textbf{Coq}}
\newcommand{\Arns}{Arboles Roji-negros}
\newcommand{\Arn}{Árbol Roji-negro}
\newcommand{\arn}{árbol roji-negro}
\newcommand{\arns}{arboles roji-negros}
%\usepackage[round]{natbib}

%para pintar arboles bonitos...
\usepackage{tikz}
\usetikzlibrary{arrows}
%\usetikzlibrary{arrows}


\tikzset{
treenode/.style = {align=center, inner sep=0pt, text centered,
font=\sffamily},
arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
fill=black, text width=1.5em},% arbre rouge noir, noeud noir
arn_r/.style = {treenode, circle, white, draw=red, fill= red,
text width=1.5em, very thick},% arbre rouge noir, noeud rouge
arn_x/.style = {treenode, rectangle, white, draw=black, fill= black,
minimum width=0.5em, minimum height=0.5em},% arbre rouge noir, nil
arn_bb/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=gray,
fill=gray, text width=1.5em},
arn_nb/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
fill=white, text width=1.5em},
arn_w/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=brown,
fill=brown, text width=1.5em},
arn_xb/.style = {treenode, rectangle, white, draw=gray, fill= gray,
minimum width=0.5em, minimum height=0.5em}
}

\renewcommand\cftsecpresnum{\S}
\renewcommand\cftsubsecpresnum{\S}   

\theoremstyle{plain}
\newtheorem{thm}{Teorema}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposici\'on}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definci\'on}[section]
\newtheorem{exmp}{Ejemplo}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}


\begin{document}
%------------------------------

\begin{titlepage}
\thispagestyle{empty}
\begin{minipage}[c][0.17\textheight][c]{0.25\textwidth}
\begin{center}
\includegraphics[width=3.5cm, height=3.5cm]{Escudo-UNAM.pdf}
\end{center}
\end{minipage}
\begin{minipage}[c][0.195\textheight][t]{0.75\textwidth}
\begin{center}
\vspace{0.3cm}
\textsc{\large Universidad Nacional Aut\'onoma de M\'exico}\\[0.5cm]
\vspace{0.3cm}
\hrule height2.5pt
\vspace{.2cm}
\hrule height1pt
\vspace{.8cm}
\textsc{Facultad de Ciencias}\\[0.5cm] %
\end{center}
\end{minipage}

\begin{minipage}[c][0.81\textheight][t]{0.25\textwidth}
\vspace*{5mm}
\begin{center}
\hskip2.0mm
\vrule width1pt height13cm 
\vspace{5mm}
\hskip2pt
\vrule width2.5pt height13cm
\hskip2pt
\vrule width1pt height13cm \\
\vspace{5mm}
\includegraphics[height=4.0cm]{Escudo-FCIENCIAS.pdf}
\end{center}
\end{minipage}
\begin{minipage}[c][0.81\textheight][t]{0.75\textwidth}
\begin{center}
\vspace{1cm}

{\large\scshape Verificación formal de arboles roji-negros}\\[.2in]

\vspace{2cm}            

\textsc{\LARGE T\hspace{1.5cm}E\hspace{1.5cm}S\hspace{1.5cm}I\hspace{1.5cm}S}\\[0.5cm]
\textsc{\large que para obtener el t\'itulo de:}\\[0.5cm]
\textsc{\large Licenciado en Ciencias de la Computación}\\[0.5cm]
\textsc{\large presenta:}\\[0.5cm]
\textsc{\large {David Felipe Hern\'andez Chiapa}}\\[2cm]          

\vspace{0.5cm}

{\large\scshape Tutores:\\[0.3cm] {Dra. Lourdes del Carmen Gonzalez Huesca}}\\[.2in]

\vspace{0.5cm}

\large{Ciudad Universitaria, Ciudad de México,}{ }{2020}
\end{center}
\end{minipage}
\end{titlepage}



%---------------------------------
\frontmatter
%\maketitle
\chapter*{}
\begin{flushright}%
\emph{Dedicatoria ...}
\thispagestyle{empty}
\end{flushright}

\chapter{Agradecimientos}
\spacing{1.5}%\doublespacing

\tableofcontents
\listoffigures


\mainmatter

\chapter{Introducción} 
\section{Motivación}
\section{Arboles Roji-negros}
Los {\arns} son una estructura de datos donde las operaciones de inserci\'on, eliminaci\'on y 
búsqueda se efectúan
en tiempo logarítmico, es decir, la complejidad de esas operaciones es $O(log(n))$, estos son una 
subclase de los
arboles binarios de búsqueda, en los cuales la complejidad de dichas operaciones crece hasta $O(n)$. Esta
mejora en la complejidad se obtiene 
gracias a la introducción de colores a los nodos del \'arbol y a invariantes relacionados con estos 
colores, las cuales describiremos 
mas adelante.
\subsection{Definici\'on de {\arns}}
Un {{{\arn}}} se define de la siguiente manera:
\begin{defn}
Un \'arbol binario de búsqueda es un {\arn} si satisface lo siguiente:
\begin{enumerate}
    \item Todos sus nodos son rojos o negros.
    \item El \'arbol vació es negro.
    \item La raíz es negra.
    \item Las siguientes invariantes se tienen que cumplir:
    \begin{itemize}
        \item Un nodo rojo debe tener hijos negros.
        \item Todos los caminos de la raíz a las hojas deben tener la misma cantidad de nodos negros.
        \item Todas las hojas del \'arbol son vacías y de color negro\footnote{Esta invariante no es del 
        todo necesaria, en capítulos posteriores apreciar que las hojas no tienen color, por la 
        construcción de estas.}.
    \end{itemize}
\end{enumerate}
\end{defn}
Se presenta en la Figura 1.1 un ejemplo de un {\arn}.

\begin{figure}
\centering 
\captionsetup{justification=centering}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;

\end{tikzpicture}
\caption {\Arn con nodos vac\'ios.}
\end{figure}

Nos interesa estudiar este tipo no trivial de arboles binarios de búsqueda para poder demostrar la 
correcci'on de estos usando el asistente de pruebas {\coq} y así poder mostrar las ventajas, y 
problemáticas de este proceso.
\section{Traducción de Haskell a {\coq} (hs-to-coq)}

\section {Sobre este trabajo}
El contenido, demostraciones de este trabajo se encuentran almacenados en ...bla.... Aqu\'i se presentan 
definiciones, lemas y clases sin incluir las demostraciones en {\coq}, es decir, los scripts de prueba. 
En su lugar se describen de forma informal las demostraciones para poder entender en alto nivel la 
estructura de la verificaci\'on formal realizada.

\chapter{Implementación de arboles roji-negros en {\coq}}
\section{Traducción de implementaciones}
Se tuvieron varias aproximaciones para la implementación de {{{{\arn}}}s}; la primera fue obtener las 
implementaciones en Haskell de estos\cite{tesisG} y pasar estas implementaciones como entrada a 
hs-to-coq, la segunda aproximación, y la que se uso para esta tesis, fue obtener la implementación de 
Okasaki traducida a Coq  \cite{MSetRBT}, con la diferencia de que se usaron las bibliotecas de Haskell 
que contienen los tipos y comparaciones, estas obtenidas de la traducción de estas bibliotecas a Coq, en 
lugar de usar las bibliotecas ya existentes de Coq.
A continuación profundizaremos acerca de estos dos métodos.
\subsection{Traducción directa de implementaciones de Haskell a Coq}
De un trabajo anterior\cite{tesisG} se obtuvieron diversas implementaciones de {\arns} la mayor parte de 
estas cambiaba principalmente en las implementaciones de las operaciones de borrado, siendo esta la 
operación mas compleja. 
Estas diversas implementaciones van desde la implementación de Okasaki\footnote{siendo esta la m\'as 
simple}, constructores inteligentes\footnote{implementaci\'on anterior con optimizaciones} y tipos 
anidados\footnote{una implementaci\'on totalmente diferente a las anteriores}.

Por la compleja naturaleza de estas implementaciones\footnote{incluso Okasaki} la traducción manual del 
código de Haskell resulto ser muy problemática,
esto porque las implementaciones en Haskell se aprovechan del hecho de que en este lenguaje se pueden dar
funciones parciales, lo cual resulta problemático cuando se quiere traducir a Coq, ya que este lenguaje 
únicamente acepta funciones totales.

Por lo expuesto anteriormente se opto por usar la herramienta \textbf{hs-to-coq} para facilitar la 
traducci\'on, pero por las mismas razones antes descritas\footnote{las funciones no eran totales},
la herramienta caia en alguna de estas dos situaciones:

\begin{itemize}
    \item El tiempo de ejecuci\'on de la herramienta era muy alto y eventualmente los recursos de la 
    maquina virtual, donde esta herramienta se ejecuto, se quedaba sin recursos\footnote{en especial 
    memoria}.
    \item La herramienta generaba c\'odigo en Coq pero con elementos de Haskell cuyas bibliotecas todavía
    no habían sido traducidas del todo.
\end{itemize}{}

Se busco otra acercamiento para poder verificar esta estructura; la herramienta hs-to-coq tiene parte de 
las bibliotecas de Haskell traducidas a Coq, entonces se uso la implementación de {\arns} de las 
bibliotecas de {\coq}\cite{MSetRBT} pero usando los tipos y comparaciones de tipos de Haskell traducidos 
a Coq.

\section{Inserción de elementos en un {\arn}}

La inserci\'on de elementos a un {\arn} es la operaci\'on mas sencilla de de las dos operaciones que 
se verificaran en este trabajo. La idea principal detrás de este algoritmo es que solo se agreguen hojas 
al \'arbol binario y se efectúen ``giros'' para mantener las invariantes de la estructura, ver figura 2.1
y 2.2.
\begin{figure}
\centering 
\captionsetup{justification=centering}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;

{
}
;
\end{tikzpicture}
\caption{{\Arn} antes de insertar nodo 7.}
\end{figure}

\begin{figure}
\centering 
\captionsetup{justification=centering}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_r] {7}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;

{
}
;
\end{tikzpicture}
\caption{{\Arn} después de insertar nodo 7.}
\end{figure}
\subsection{Operaciones de Balanceo}
Los ``giros'' antes mencionados están definidos en las operaciones de balanceo, se tienen dos, una 
operaci\'on para los subárboles izquierdos y otra para los derechos. Estas operaciones de balanceo, 
c\'odigo en figura 2.3, se encargan de solucionar los casos en los que inmediatamente después de 
agregar una hoja los invariantes son violados, por ejemplo, dos nodos rojos que resultan contiguos en 
algún lugar de la estructura del \'arbol. Mas a\'un solo dos de los tres invariantes pueden ser violados 
cuando se agrega un nuevo nodo, siendo estos que hayan dos nodos rojos contiguos o que la raíz del árbol 
resulte roja\footnote{esto no se arregla con giros, si no, pintando la raíz de negro después de 
insertar}.

El giro elimina el doble nodo rojo, al crear solo un nodo rojo con dos hijos negros, de igual manera al 
tener dos hijos negros nos aseguramos que el árbol crece de manera controlada en n\'umero de nodos 
negros\footnote{este n\'umero de nodos negros se conoce como altura negra}, ya que en ningún momento se 
están agregando dos nodos negros contiguos. Cabe mencionar que esta es la única operación en donde se 
agregan nodos negros con la excepción de $makeBlack$, la cual describiremos mas adelante.
\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}
Definition lbal {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match l with
 | T R (T R a x b) y c => T R (T B a x b) y (T B c k r)
 | T R a x (T R b y c) => T R (T B a x b) y (T B c k r)
 | _ => T B l k r
 end.

 Definition rbal {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R (T R b y c) z d => T R (T B l k b) y (T B c z d)
 | T R b y (T R c z d) => T R (T B l k b) y (T B c z d)
 | _ => T B l k r
 end.
\end{minted}
\caption{Funciones de Balanceo.}
\end{figure}

Mas adelante se explicar\'a porque solamente nos concentramos en estos cuatro casos y porque la mayor 
parte de los casos se reacomodan en un \'arbol con ra\'iz negra.

\subsection {Funci\'on de inserci\'on}
Con esta funci\'on es donde por primera vez podemos apreciar el uso de las  bibliotecas de Haskell, 
podemos apreciar como los tipos que estamos agregando al \'arbol son tipos ordenados de la biblioteca 
$Base$ de \textbf{GHC} y por esa misma raz\'on estamos usando las comparaciones de esa biblioteca.
\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}
Fixpoint ins {a} `{GHC.Base.Ord a} (x:a) (s:RB a) :=
 match s with
 | E => T R E x E
 | T c l y r =>
    if x GHC.Base.< y : bool then 
      match c with
       | R => T R (ins x l) y r
       | B => lbal (ins x l) y r
      end
    else 
    if x GHC.Base.> y : bool then 
      match c with
       | R => T R l y (ins x r)
       | B => rbal l y (ins x r)
      end
    else s
 end.
\end{minted}
\caption{Funci\'on ins.}
\end{figure}

Leyendo mas detenidamente la funci\'on, figura 2.4, se puede observar que las operaciones de balanceo 
solo se efectúan cuando el nodo por el que se esta pasando es negro, esto sucede por la raz\'on de que 
estos son los nodos  que se toman en cuenta para decidir si un \'arbol esta balanceado. Al aplicar las 
operaciones de balanceo en estos nodos, nos aseguramos de no quedar con nodos negros extras en alguno de 
los hijos del nodo al que se le esta aplicando la operación de balanceo. Esto se puede apreciar si nos 
regresamos a las definiciones de las operaciones de balanceo, tomemos $rbal$\footnote{Con $lbal$ la idea 
es an\'aloga}, tenemos dos casos:

\begin{itemize}
    \item Sean $x$, $y$ y $z$ nodos del \'arbol y sea $n$ un subárbol, $x$ es el nodo al que se le aplica
    la operaci\'on de balanceo, $n$ es el subárbol izquierdo, $y$ es el nodo derecho  de $x$ y $z$ es 
    hijo de $y$. Suponiendo que $y$ y $z$ son rojos\footnote{se viola una invariante, dos nodos rojos 
    contiguos}, se cae en cualquiera de los dos casos de $rbal$ que no son el caso general. En este 
    momento es donde se efectúa el ``giro'' del árbol y resulta lo siguiente: $x$ se vuelve el hijo 
    izquierdo de $y$ y $z$ se pinta de negro.
    
    En el momento en que $x$ se convierte en hijo izquierdo de $y$ el \'arbol se desbalancea, es por esto
    que se pinta de negro a $z$, así los dos nodos negros son hijos de $y$ y la invariante se conserva.
    \item En cualquier otro caso el \'arbol no sufre modificaci\'on alguna.
\end{itemize}{}

Esta función de inserción puede no cumplir con una de las invariantes, que la raíz del árbol sea negra, 
es por esto que se introducen las definiciones de la figura 2.5.

\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}
Definition makeBlack {a} `{GHC.Base.Ord a} (t:RB a) :=
 match t with
 | E => E
 | T _ a x b => T B a x b
 end.

Definition insert {a} `{GHC.Base.Ord a} (x:a) (s:RB a) := makeBlack (ins x s).
\end{minted}
\caption{Definiciones para pintar ra\'iz de negro.}
\end{figure}

La definici\'on $makeBlack$ únicamente colorea cualquier nodo de color negro y la definición $insert$ es 
una envoltura de $ins$, con la cual nos aseguramos de que la ra\'iz de los arboles siempre sea de color 
negro.

Estas funciones y definiciones son suficientes para poder construir {\arns} que respeten las invariantes 
que planteamos en la definici\'on 1.2.1. 

\section{Eliminación de elementos en un {\arn}}

Como se menciono en la secci\'on pasada la operaci\'on de eliminaci\'on es significativamente mas 
compleja que su contra parte, esto se debe al hecho de que se pueden eliminar nodos de cualquier parte 
del \'arbol, mientras que en la inserci\'on solo se agregaban hojas de color rojo, es decir, la altura no
se modifica en la inserción\cite{RBTypes}, solo hasta que se aplica el balanceo.

El poder eliminar nodos de cualquier parte de un \'arbol presenta una problemática muy grande para el 
balanceo del mismo, esto porque al eliminar un nodo del \'arbol, los dos subárboles de este tienen que 
concatenarse de alguna manera y las invariantes de los {\arns} tienen que respetarse.

\begin{figure}
\centering 
\captionsetup{justification=centering}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;

{
}
;
\end{tikzpicture}
\caption{{\Arn antes de eliminar nodo 6.}}
\end{figure}

\begin{figure}
\centering 
\captionsetup{justification=centering}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
%\node [arn_n] at (-2,0) {6}

        \node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_r] {5}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
            }
;
\end{tikzpicture} 
\begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
           
            \node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }

;
\end{tikzpicture}

\caption{{\Arn} roto, después de eliminar nodo 6.}
\end{figure}

\begin{figure}
\centering 
\captionsetup{justification=centering}
\label{arbolRB}
 \begin{tikzpicture}[-,level/.style={sibling distance = 4cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {5}
        child{ node [arn_r] {2} 
            child{ node [arn_n] {1} 
                child{ node [arn_x] {}} %for a named pointer
                child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
                child{ node [arn_r] {3}
                    child{ node [arn_x] {}}
                    child{ node [arn_x] {}}
                }
                child{ node [arn_x] {}}
            }                            
        }
        child{ node [arn_n] {8}
            child{ node [arn_x] {}}
            child{ node [arn_r] {9}
                child{ node [arn_x] {}}
                child{ node [arn_x] {}}
            }
        }
;

{
}
;
\end{tikzpicture}
\caption{{\Arn} despues de aplicar función append.}
\end{figure}

\subsection{Funci\'on de eliminaci\'on}

Para poder comprender la l\'ogica de las funciones\footnote{auxiliares y principales} de la operaci\'on
de eliminaci\'on es necesario empezar por la funci'on que elimina los nodos, ver la figura 2.9. La idea 
principal es bastante simple, como los \arns son \'arboles de busqueda, lo primero que hacemos es buscar 
el nodo a eliminar, si se encuentra se elimina y se ``pegan'' los subárboles restantes de esta 
operaci\'on, ver figuras 2.6, 2.7 y 2.8. A continuaci\'on se describe mas a fondo los casos de la misma:

\begin{itemize}
    \item Si se recibe un \'arbol vacío como argumento de la funci'on se regresa el mismo, pues eliminar 
    un elemento del \'arbol vacío resulta en el mismo. Tmabien este caso sirve para cuando un elemento no
    es encontrado en el \'arbol, es el caso base de la recursi\'on de búsqueda.
    \item En otro caso, se realiza recursivamente la búsqueda del elemento a eliminar. Si el nodo no 
    contiene el elemento que buscamos, comparamos si el elemento es menor o mayor para seguir buscando en
    el \'arbol izquierdo o derecho respectivamente y si el nodo es negro se realiza la operaci'on 
    $lbalS$\footnote{Se explican mas adelante} si la operación recursiva se hace al árbol izquierdo o 
    $rbalS$\footnote{Se explican mas adelante} si la operación recursiva se hace al árbol derecho. Si el 
    elemento en el que estamos no es ni mayor ni menor al que buscamos, en ese caso eliminamos el 
    elemento y pegamos los subarboles restantes usando la función $append$\footnote{Se explican mas 
    adelante}.
\end{itemize}

Podemos ver que las funciones de balanceo $lbalS$ y $rbalS$ se aplican cuando el nodo en el que estamos 
parados es negro, esto evita que después de eliminar un nodo y aplicar la funci\'on $append$, se acabe 
con dos nodos rojos seguidos, es decir, que el hijo y alguno de los nietos del nodo en el que estamos 
parados sean rojos.  

\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}
Fixpoint del {a} `{GHC.Base.Ord a} (x:a) (t:RB a) :=
 match t with
 | E => E
 | T _ a y b =>
    if x GHC.Base.< y : bool then 
      match a with
       | T B _ _ _ => lbalS (del x a) y b
       | _ => T R (del x a) y b
      end
    else 
    if x GHC.Base.> y : bool then 
      match b with
       | T B _ _ _ => rbalS a y (del x b)
       | _ => T R a y (del x b)
      end
    else append a b
 end.

Definition remove x t := makeBlack (del x t).
\end{minted}
\caption{Función de eliminación}
\end{figure}

\subsection{Funci\'on de concatenaci\'on}

\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}
Fixpoint append {a} `{GHC.Base.Ord a} (l:RB a) : RB a -> RB a :=
 match l with
 | E => fun r => r
 | T lc ll lx lr =>
   fix append_l (r:RB a) : RB a :=
   match r with
   | E => l
   | T rc rl rx rr =>
     match lc, rc with
     | R, R =>
       let lrl := append lr rl in
       match lrl with
       | T R lr' x rl' => T R (T R ll lx lr') x (T R rl' rx rr)
       | _ => T R ll lx (T R lrl rx rr)
       end
     | B, B =>
       let lrl := append lr rl in
       match lrl with
       | T R lr' x rl' => T R (T B ll lx lr') x (T B rl' rx rr)
       | _ => lbalS ll lx (T B lrl rx rr)
       end
     | B, R => T R (append_l rl) rx rr
     | R, B => T R ll lx (append lr r)
     end
   end
 end.
\end{minted}
\caption{Funci\'on de concatenaci\'on, append}
\end{figure}

\subsection{Extensi\'on de funciones de balanceo}

Para poder definir la funci\'on de eliminaci\'on es necesario extender las funciones de balanceo, esto 
porque al eliminar nodos se presentan nuevos casos en estas funciones.

Estas funciones, figuras 2.6, 2.7 y 2.8, son tres: $rbal'$, $lbalS$, $rbalS$. La primera de estas 
tres es idéntica a la función $rbal$, figura 2.1, lo \'unico que cambia es el orden de la caza de 
patrones, esto se cambio por conveniencia al momento de desarrollar las demostraciones, toda la 
funci\'on de eliminación usa esta variante de la funci\'on de balanceo derecha.


Las funciones $rbalS$ y $lbalS$ agregan casos adicionales a las funciones de balanceo usadas para la 
operaci\'on de inserci\'on y la idea de la extensión es análoga entre las dos, se describe esta idea a 
continuación:
En la funci\'on $rbalS$, 

\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}
Definition rbal' {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R b y (T R c z d) => T R (T B l k b) y (T B c z d)
 | T R (T R b y c) z d => T R (T B l k b) y (T B c z d)
 | _ => T B l k r
 end.

\end{minted}
\caption{Funci\'on de balanceo de lado derecho alternativa.}
\end{figure}

\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}

Definition lbalS {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match l with
 | T R a x b => T R (T B a x b) k r
 | _ =>
   match r with
   | T B a y b => rbal' l k (T R a y b)
   | T R (T B a y b) z c => T R (T B l k a) y (rbal' b z (makeRed c))
   | _ => T R l k r 
   end
 end.

\end{minted}
\caption{Funciones de balanceo de la izquierdo extendida.}
\end{figure}

\begin{figure}
\centering 
\captionsetup{justification=centering}
\begin{minted}{coq}

Definition rbalS {a} `{GHC.Base.Ord a} (l:RB a) (k:a) (r:RB a) :=
 match r with
 | T R b y c => T R l k (T B b y c)
 | _ =>
   match l with
   | T B a x b => lbal (T R a x b) k r
   | T R a x (T B b y c) => T R (lbal (makeRed a) x b) y (T B c k r)
   | _ => T R l k r 
   end
 end.

\end{minted}
\caption{Funciones de balanceo de lado derecho extendida.}
\end{figure}



\chapter{Verificación formal de {\arns}}
Se menciono en el primer cap\'itulo de este trabajo que los {\arns} son una estructura de datos que mejora el 
tiempo de acceso, de inserción y eliminación de
elementos con respecto a otras estructuras de datos, como las listas ligadas o doblemente ligadas. En el 
segundo cap\'itulo se muestran las implementaciones de los algoritmos de esta  estructura de datos y podemos 
notar como estas implementaciones no son triviales, es decir, son rebuscadas, enredosas y complicadas de 
programar en un lenguaje del paradigma funcional como lo es {\coq}. 
Por esta razón es que nos preocupa que las implementaciones que realicemos sean correctas y completas, es
decir, se desea verificar formalmente que las implementaciones de las operaciones descritas en el 
capitulo anterior.

Para esto se usara, de igual manera, {\coq}. La verificaci\'on se divide en varios pasos:
\begin{itemize}
    \item Capturar los invariantes de los {\arns} usando definiciones inductivas en {\coq}, de esta 
    manera podemos saber si las operaciones que se implementaron las respetan.
    \item Enunciar lemas, corolarios, teoremas que describan los comportamientos de las operaciones que 
    queremos verificar y escribirlos en {\coq}.
    \item Por \'ultimo demostrar todos los enunciados del punto anterior utilizando el asistente de 
    pruebas.
\end{itemize}{}
\section{Capturando los invariantes de los {\Arns}}
Una de las partes mas importantes de la verificaci\'on formal de cualquier estructura de datos es 
capturar sus invariantes de manera correcta, es decir, poder escribir una o varias definiciones 
inductivas que describan a la estructura de datos y sus invariantes. Después, con estas 
definiciones es que se enuncian los lemas, clases y posteriormente instancias de estas. 

A continuaci\'on se describen dos conjuntos de definiciones inductivas, muy similares entre ellas, para 
poder verificar formalmente esta estructura de datos. La primera es un primer intento que es insuficiente
ya que los tipos inductivos y los principios de demostraci\'on no son los \'optimos. El segundo intento 
es un conjunto de definiciones inductivas que tienen mas detalle para describir los invariantes. Estas 
definiciones est\'an relacionadas con las propiedades de las operaciones de inserci\'on y eliminaci\'on. 

\subsection{Primer Conjunto de Definiciones Inductivas}
Los dos conjuntos de definiciones inductivas comparten la misma idea; una definici\'on que describa lo 
que es un {\arn} y otra definici\'on mas relajada de la misma.

La primera definici\'on, llamada $isRb$, esta definida de la siguiente manera: 
\begin{minted}{coq}
Inductive isRB : Tree -> color -> nat -> Prop :=
 | IsRB_leaf: forall c, isRB E c 0
 | IsRB_r: forall tl k kv tr n,
          isRB tl Red n ->
          isRB tr Red n ->
          isRB (T Red tl k kv tr) Black n
 | IsRB_b: forall c tl k kv tr n,
          isRB tl Black n ->
          isRB tr Black n ->
          isRB (T Black tl k kv tr) c (S n).
\end{minted}
Esta definici\'on tiene tres casos, los describimos a continuaci\'on:
\begin{itemize}
        \item \textbf{IsRB\_Leaf} - el árbol vacío con altura negra 0 es roji-negro. En este caso si se 
        tiene un solo nodo, es decir una hoja, la definici\'on cae en el caso $isRB_Leaf$. La altura 
        negra siempre va a ser 0 ya que estas son nodos vacíos\footnote{estos nodos no tienen color pero 
        para términos prácticos, se puede decir que son negros.}.
        \item \textbf{IsRB\_r} - un árbol rojo con altura negra $n$ y color negro, con hijos roji-negros
        con color rojo y altura negra $n$. En este segundo caso al recibir un \'arbol rojo, ninguno de 
        sus hijos puede ser rojo, esto se enuncia haciendo que las llamadas recursivas de los 
        antecedentes sean rojas y como no esta analizando ningún nodo negro la altura negra se conserva 
        en $n$.   
        \item \textbf{IsRB\_b} - un árbol negro con altura negra $n+1$ y cualquier color, con hijos
        roji-negros de altura $n$ y color negro. En este \'ultimo caso como recibimos un \'arbol de color
        negro la altura negra del consecuente es $S(n)$, también nos hace llamadas recursivas, en los 
        antecedentes, con color negro, al pasar esto los nodos pueden ser tanto negros como rojos y la 
        altura regresa a ser $n$ porque no se esta contando el nuevo nodo negro del consecuente.
\end{itemize}

Con estos tres casos podemos asegurar que las invariantes se respetan, pero esta funci\'on inductiva es 
demasiado restrictiva para poder demostrar las propiedades de los {\arns}, por esto pasamos a la segunda 
definici\'on inductiva, $nearRB$,  esta permite mas flexibilidad en el \'arbol, se muestra y describe a 
continuaci\'on:

\begin{minted}{coq}
Inductive nearRB : Tree -> nat -> Prop :=
| nrRB_r: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Red tl k kv tr) n
| nrRB_b: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Black tl k kv tr) (S n).
\end{minted}
Podemos apreciar que solo se tienen dos casos y no se tiene un argumento para un color, sin embargo, a 
diferencia de $isRB$ esta no se llama recursivamente, en lugar de eso se llama a $isRb$ inmediatamente, 
además podemos ver que ambas definiciones comparten el contador de nodos negros.
Con estas modificaciones se permite una cosa, que en la ra\'iz del \'arbol puedan haber a lo mas dos 
nodos rojos contiguos.

\subsubsection{Intento de Verificaci\'on}
Utilizando las funciones inductivas descritas en esta secci\'on se realiz\'o un intento fallido de 
verificac\'on de la operaci\'on de inserci\'on, como se muestra en \cite{appel}, sin embargo al estar 
desarrollando la demostraci\'on se encontró un problema, la falta de un conjunto de hipótesis para poder 
probar una meta. Esto se debe probablemente a una mala elección de estilo de demostraci\'on, 
implementaci\'on o de las definiciones inductivas mostradas anteriormente. Se noto que el hecho de que 
toda la informaci\'on referente a los invariantes estuviera codificada en las dos funciones inductivas, 
sin uso de ``funciones auxiliares'', complica la verificaci\'on. Se llego a esta conclusi\'on ya que el 
caso ``sencillo'' de la verificaci\'on de {\arns} es la inserci\'on y con este conjunto de funciones 
inductivas las demostraciones se volvían muy largas y complicadas de seguir.

\subsection{Segundo Conjunto de Definiciones Inductivas}

Con el conocimiento que se obtuvo del conjunto de definiciones anterior, nos realizamos la siguiente 
pregunta: ¿como capturar las invariantes de los {\arns} y al mismo tiempo facilitar la verificaci\'on de 
estos?

Utilizamos una definición inductiva, llamada $is\_redblack$ para poder capturar los invariantes, la cual
lleva como parámetros un contador y un \'arbol. El contador lleva el control de la cantidad de nodos
negros, es decir la altura negra del nodo, mientras que el \'arbol es aquel que estamos buscando
verificar que cumpla con las invariantes de un {\arn}. Se presenta esta definici\`on a continuaci\'on:

\begin{minted}{coq}
Inductive is_redblack {a} `{GHC.Base.Ord a} : nat -> RB a -> Prop :=
 | RB_Leaf : is_redblack 0 E
 | RB_R n l k r : notred l -> notred r ->
                  is_redblack n l -> is_redblack n r ->
                  is_redblack n (T R l k r)
 | RB_B n l k r : is_redblack n l -> is_redblack n r ->
                  is_redblack (S n) (T B l k r).
\end{minted}

Podemos notar ciertas similitudes con la definición inductiva de las secci\'on pasada, sin embargo, el 
principal cambio que presenta esta definición es el hecho de que se saca el control de los colores de los
subárboles de los parámetros de la definici\'on y se crea la funci\'on $notred$, la cual, como su nombre 
dice, verifique el \'arbol que se le este pasando no tenga raíz roja. Esta definici\'on tiene tres casos;
$RB\_Leaf$, $RB\_R$ y $RB\_B$. Desarrollando la idea de cada caso:

\begin{itemize}
        \item \textbf{RB\_Leaf} - el árbol vació es roji-negro. Este caso nos dice que el \'arbol vacío 
        es un {\arn}.
        \item \textbf{RB\_R} - un árbol rojo donde lleves contados $n$ nodos negros, donde sus hijos sean
        {\arns} y no sean rojos. Este caso nos dice explícitamente que los subárboles del árbol que esta 
        recibiendo la función no pueden ser rojos, esto porque el árbol que se esta analizando tiene raíz
        roja. Como no se esta analizando algún nodo negro, la altura negra se mantiene en $n$.
        \item \textbf{RB\_B} - un árbol negro donde lleves contados $n+1$ nodos negros, incluido el 
        actual, y sus hijos sean {\arns}. En este ultimo caso se tiene la libertad de que los subárboles 
        sean del color que sea, pero la altura del consecuente es $S(n)$ porque el nodo que se esta 
        analizando es de color negro, los antecedentes al no tomar en cuenta a su nodo padre tienen 
        altura $n$.
\end{itemize}

Esta definici\'on captura los invariantes que estamos buscando, sin embargo no es suficiente para poder 
probar la correcci\'on de los {\arns}, esta es demasiado restrictiva y costaría mucho trabajo proceder con las
demostraciones solo con esta definici\'on. Por esta razón se agregan dos definiciones inductivas auxiliares; 
$redred\_tree$ y $nearly\_redblack$: 

\begin{minted}{coq}
Inductive redred_tree {a} `{GHC.Base.Ord a} (n:nat) : RB a -> Prop :=
 | RR_Rd l k r : is_redblack n l -> is_redblack n r -> redred_tree n (T R l k r).

Inductive nearly_redblack {a} `{GHC.Base.Ord a} (n:nat)(t:RB a) : Prop :=
 | ARB_RB : is_redblack n t -> nearly_redblack n t
 | ARB_RR : redred_tree n t -> nearly_redblack n t.
\end{minted}

Podemos notar que estas definiciones son versiones mas relajadas de $is\_redblack$. La definici\'on 
$nearly\_redblack$ permite que existan dos nodos rojos en la ra\'iz del \'arbol, aprovech\'andose de
$redred\_tree$, pues esta definici\'on es exactamente el caso $RB\_R$ pero sin las restricciones de que 
los sub\'arboles sean rojos, lo cual nos permite que hayan dos nodos rojos exactamente en la ra\'iz. 
Entonces un $nearly\_redblack$ es un {\arn} con la excepci\'on de que la ra\'iz puede ser roja. 

Finalmente, lo que se busca demostrar es que los {\arns} con las operaciones de inserci\'on y 
eliminaci\'on están dentro de la siguiente clase de arboles:

\begin{minted}{coq}
Class redblack {a} `{GHC.Base.Ord a} (t:RB a) := 
                            RedBlack : exists d, is_redblack d t.
\end{minted}

Lo que estamos describiendo con este enunciado es que un {\arn} es aquel que tiene una altura negra $d$ y
cumple con las invariantes establecidas por la definici\'on $is\_redblack$.

\subsubsection{Segundo Intento de Verificaci\'on}
En contraste con el conjunto de de definiciones de la secci\'on pasada, la definici\'on de 
$nearly\_redblack$ se reescribe, dejando de codificar las invariantes en las llamadas recursivas de la 
definición, creando funciones auxiliares para capturar los invariantes de manera mas sencilla, como 
$redred\_tree$ y $notred$. Además se crea la clase de {\arns}, lo cual afina mas la definici\'on de un 
{\arn}. Tomando en cuenta todas estas modificaciones a las definiciones fue que se eligió este conjunto 
para verificar formalmente la estructura de datos\footnote{La elecci\'on de este conjunto fue correcta ya
que facilito la demostraci\'on de las propiedades y probo ser suficiente para verificar la estructura.}. 
Estas definiciones inductivas fueron obtenidas de \cite{MSetRBT}.

\section{Verificación de la operación de inserción}

Para poder realizar la verificaci\'on de la operaci\'on de inserci\'on es necesario escribir enunciados, ya sean 
lemas, proposiciones, etc., usandoi las definiciones inductivas presentadas en la secci\'on pasada, es decir, 
$is\_redblack$, $nearly\_redblack$ y $redred\_tree$.

A continuaci\'on mostraremos dos lemas: $ins\_rr\_rb$, $ins\_arb$, y una instancia\cite{classes} de la clase 
$redblack$, $add\_rb$. Estos lemas y la instancia fueron obtenidos de \cite{MSetRBT} y la idea principal de estos lemas es dejarnos ver que ciertos arboles que acepten las definiciones mas generales, $nearly\_redblack$ y $redred\_tree$, tambien respetan la definici\'on de $is\_redblack$.

\subsection{Primer Lema}

\begin{minted}{coq}
Lemma ins_rr_rb {a} `{GHC.Base.Ord a} (x:a) (s: RB a) (n : nat) :
is_redblack n s -> ifred s (redred_tree n (ins x s)) (is_redblack n (ins x s)).
\end{minted}
 En este primer lema enunciamos lo siguiente: Sea $s$ un {\arn} bajo la definici\'on de $is\_redblack$, entonces 
 si $s$ es un \'arbol con raiz roja, insertar un elemento $x$ en $s$ resulta en un \'arbol que cumple la 
 definci\'on de $redred\_tree$, en otro caso cumple con la definici\'on de $is\_redblack$.

 En otras palabras lo que este enunciado quiere decirnos es que si tenemos un {\arn} e insertamos un elemento a 
 ese \'arbol el resultado puede tener ra\'iz roja, e incluso puede tener dos nodos rojos, uno en la ra\'iz y otro
 en cualquiera de los dos, o en los dos, nodos que siguen.

 La demostraci\'on de este lema comienza con una inducci\'on sobre el antecedente del lema, lo cual resulta en 
 tres casos:
 \begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
______________________________________(1/3)
ifred E (redred_tree 0 (ins x E)) (is_redblack 0 (ins x E))
______________________________________(2/3)
ifred (T R l k r) (redred_tree n (ins x (T R l k r))) 
                  (is_redblack n (ins x (T R l k r)))
______________________________________(3/3)
ifred (T B l k r) (redred_tree (S n) (ins x (T B l k r)))
                  (is_redblack (S n) (ins x (T B l k r)))
 \end{minted}

 La funci\'on $ifred$ que se usa en este lema es una funci\'on auxiliar que nos ayuda a decidir si un \'arbol es 
 rojo o no. 

 En el primero de estos casos notamos que su soluci\'on se da simplificando las funciones y resulta en uno de los
 casos de $is\_redblack$, especificamente en el caso $RB\_R$, ya que el \'arbol vacio no es rojo y la 
 simplificaci\'on de $(ins(x,E))$ resulta en un \'arbol rojo con un elemento, esto por definici\'on de $ins$.

 Los dos casos sobrantes estan relacionados con los colores de las raices del \'arbol, en el segundo el \'arbol 
 es rojo y en el tercero es negro. 
 
 Analicemos el segundo caso, como el \'arbol es rojo, entra al primer caso de $if_red$, es decir, entra al caso 
 de la definici\'on $redred\_tree$, lo cual significa que al insertar un elemento al \'arbol rojo, sin tener 
 conocimiento de como son los subárboles de este, puede resultar en un \'arbol con uno o dos nodos rojos 
 consecutivos en la ra\'iz de este, ya que la operaci'on de balanceo se fija en los nodos hijos y nietos del nodo
 al que se le aplica la operaci\'on y como los nodos hijos de la raíz \textbf{no} tienen nodo abuelo el balanceo 
 no se efectua en los nodos de la raíz, dando lugar a arboles con uno o mas nodos rojos en la raíz\footnote{hasta
 3, la raiz y sus hijos.}.
 
 El tercer caso describe el caso sobrante, el caso del \'arbol con raiz negra, este caso se complica un poco mas 
 que el anterior ya que este es el caso en el que la altura negra del \'arbol se aumenta en uno. Este caso 
 verifica que las dos funciones de balanceo, $lbal$ y $rbal$:
 
 \begin{minted}{coq}
 2 subgoals
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
n : nat
l : RB a
k : a
r : RB a
H1_ : is_redblack n l
H1_0 : is_redblack n r
IHis_redblack1 : ifred l (redred_tree n (ins x l)) (is_redblack n (ins x l))
IHis_redblack2 : ifred r (redred_tree n (ins x r)) (is_redblack n (ins x r))
______________________________________(1/2)
is_redblack (S n) (lbal (ins x l) k r)
______________________________________(2/2)
is_redblack (S n) (rbal l k (ins x r))
\end{minted}

Estos casos son análogos y los dos se resuelven simplificando las funciones de balanceo, simplificando las expresiones 
y aplicando las definiciones inductivas\footnote{$is\_redblack$, $nearly\_redblack$}.

\subsection{Segundo Lema}

\begin{minted}{coq}
Lemma ins_arb {a} `{GHC.Base.Ord a} (x:a) (s:RB a) (n:nat) : 
is_redblack n s -> nearly_redblack n (ins x s).
\end{minted}

Este segundo lema enuncia lo que en el capitulo anterior se menciono acerca de la funci\'on $ins$: La funci\'on $ins$ 
no garantiza que el \'arbol resultante sea un {\arn}, ya que es posible que se termine la ejecuci\'on de la funci\'on 
con un nodo rojo como raíz. La demostraci\'on comienza introduciendo los antecedentes a las hipótesis y aplicando el 
lema anterior, $ins\_rr\_rb$, a una de las hip\'otesis:

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : ifred s (redred_tree n (ins x s)) (is_redblack n (ins x s))
______________________________________(1/1)
nearly_redblack n (ins x s)

\end{minted}

Como no se sabe si el \'arbol $s$ tiene ra\'iz roja o negra, se tienen que probar los dos casos, uno con la hipótesis 
de que el \'arbol resultante sea $is\_redblack$ y otro con $redred\_tree$. Estos casos se resuelven sencillamente con 
la aplicación de los dos casos de la definici\'on inductiva de $nearly\_redblack$, respectivamente.

\subsection{Instancia de la Funci\'on de Inserci\'on}

Para poder probar la instancia de la clase $redblack$ se va a necesitar el siguiente lema auxiliar:

\begin{minted}{coq}
Lemma makeBlack_rb {a} `{GHC.Base.Ord a} n t : 
                         nearly_redblack n t -> redblack (makeBlack t).
\end{minted}

Este lema se resuelve destruyendo $t$, de esta manera se generan dos casos y estos se solucionan simplificando las 
expresiones y aplicando las definiciones inductivas $is\_redblack$ y $nearly\_redblack$. En seguida enunciamos la 
instancia de la clase $redblack$:

\begin{minted}{coq}
Instance add_rb {a} `{GHC.Base.Ord a} (x:a) (s: RB a) :
                                     redblack s -> redblack (insert x s).
\end{minted}

Para poder crear la instancia de la clase $redblack$ es necesario usar la definici\'on $insert$ para la cual es una 
envoltura para la funci\'on $ins$. Esta funci\'on lo que hace es pintar la ra\'iz del \'arbol resultante de la 
funci\'on $ins$ de color negro. De esta manera podemos asegurar que el \'arbol resultante ya no entra en la 
definici\'on de $redred\_tree$.

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : is_redblack n s
______________________________________(1/1)
redblack (makeBlack (ins x s))
\end{minted}

En este momento se utiliza el lema auxiliar $makeBlack\_rb$ el cual nos devuelve lo siguiente:

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
x : a
s : RB a
n : nat
H1 : is_redblack n s
______________________________________(1/1)
nearly_redblack n (ins x s)
\end{minted}

Esta ultima meta se resulve aplicando el segundo lema que enunciamos, $ins\_arb$, lo cual nos deja con una meta 
idéntica a la hipótesis H1 y con esto terminamos la verificaci\'on de la operaci\'on de inserci\'on.

Se puede decir que esta implementaci\'on de la funci\'on de inserci\'on es correcta y completa bajo las invariantes 
establecidas en las definici\'on inductiva $is_redblack$. La operaci\'on ha sido verificada formalmente, ahora 
continuaremos con la funci\'on de eliminaci\'on.  

\section{Verificación de la operación de eliminación}
\begin{minted}{coq}
Lemma append_arb_rb {a} `{GHC.Base.Ord a} (n:nat) (l r: RB a) : 
  is_redblack n l -> is_redblack n r ->
   (nearly_redblack n (append l r)) /\
   (notred l -> notred r -> is_redblack n (append l r)).


Lemma del_arb {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
 with del_rb  {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack n s -> notblack s -> is_redblack n (del x s).

Instance remove_rb s x : redblack s -> redblack (remove x s).
\end{minted}
\chapter{Conclusiones}  
%aprendiendo a usar esta cosa, it is cool-aid
\bibliographystyle{plain} % We choose the "plain" reference style
\bibliography{refs} % Entries are in the "refs.bib" file
\backmatter%@sglvgdor


\end{document}
