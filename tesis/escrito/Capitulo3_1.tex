\chapter{Verificación de {\arns}}

En el primer cap\'itulo de este trabajo se menciono que los {\arns} son una estructura de datos
que mejora el tiempo de acceso, de inserción y eliminación de elementos con respecto a otras
estructuras de datos como: las listas simples, las listas doblemente ligadas y \'arboles de
búsqueda. En el segundo cap\'itulo se muestran las implementaciones de los algoritmos de esta
estructura de datos y podemos notar como estas implementaciones no son triviales, es decir, son
rebuscadas, enredosas y complicadas de programar en un lenguaje que utilice el paradigma de programaci\'on funcional como
lo hace {\coq}, e incluso en un lenguaje con un paradigma imperativo como \textit{Java} o \textit{C}.
Por esta razón es que nos preocupa que las implementaciones que realicemos sean correctas, en otras palabras, se desea verificar que las implementaciones de las operaciones
descritas en el capitulo anterior respeten en todos los casos los invariantes de los {\arns}.

\section{Pruebas unitarias}
Las \textit{pruebas unitarias} \cite{unittest} son bloques de c\'odigo, funciones o m\'etodos, que
invocan a otros bloques para poder verificar ciertas suposiciones sobre el programa a probar. Estas
pruebas en principio deben de ser fáciles de escribir, entender, extender, que se ejecuten en poco
tiempo y sobre todo que sean fidedignas. De nada nos servirían pruebas unitarias que estén mal
escritas o que estas mismas sean demasiado complejas y puedan contener errores.

Este tipo de pruebas son usadas para verificar que cada componente de un programa funcione de
manera correcta, en el caso de los {\arns} este tipo de pruebas nos ayudan a verificar los
invariables de un determinado \'arbol. La figura \ref{unitTestjava} es una prueba unitaria
escrita en el lenguaje de programaci\'on Java, la cual verifica la altura negra de un {\arn}.

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{java}

    /* Valida que los caminos del vértice a sus hojas tengan todos
       el mismo número de vértices negros. */
    private static <T extends Comparable<T>> int
    validaCaminos(ArbolRojinegro<T> arbol,
                  VerticeArbolBinario<T> v) {
        int ni = -1, nd = -1;
        if (v.hayIzquierdo()) {
            VerticeArbolBinario<T> i = v.izquierdo();
            ni = validaCaminos(arbol, i);
        } else {
            ni = 1;
        }
        if (v.hayDerecho()) {
            VerticeArbolBinario<T> d = v.derecho();
            nd = validaCaminos(arbol, d);
        } else {
            nd = 1;
        }
        Assert.assertTrue(ni == nd);
        switch (arbol.getColor(v)) {
        case NEGRO:
            return 1 + ni;
        case ROJO:
            return ni;
        default:
            Assert.fail();
        }
        // Inalcanzable.
        return -1;
    }

\end{minted}
\caption{Prueba unitaria escrita en Java.\cite{CanekPU}}
\label{unitTestjava}
\end{figure}

Sin embargo, el hecho de que las pruebas unitarias puedan verificar los invariantes de un \'arbol
dado, no nos asegura que todos los \'arboles creados por nuestras operaciones de inserci\'on y
eliminaci\'on los respeten. La \'unica manera de que esta prueba podr\'ia verificar esto ser\'ia
realizando todas las combinaciones de operaciones y entradas posibles y aplicar la prueba a todos los
resultados de estas entradas. Esto es una prueba exhaustiva y en este caso \footnote{De hecho en la
mayoria.} las posibildades son infinitas, es decir, no existe modo de realizar todas estas pruebas
en un tiempo razonable, lo cual contradice totalmente la definici\'on de prueba unitaria.


\section{Verificaci\'on Formal en {\coq}}

Es claro que las pruebas unitarias no nos son suficientes para poder verificar formalmente un
programa, es por esto que se requieren realizar demostraciones matemáticas para poder obtener los
resultados que buscamos, pero de igual manera no queremos escribir a mano estas demostraciones ya
que al igual que las pruebas unitarias estas son susceptibles al error humano, por esta raz\'on se
usar\'a {\coq} para realizar estas pruebas formales.

La verificaci\'on formal de un programa usando {\coq} esta compuesto de las siguientes etapas:
\begin{itemize}
    \item Capturar los invariantes de los {\arns} usando definiciones inductivas en {\coq}, de
    esta manera podemos saber si las operaciones que se implementaron las respetan.
    \item Enunciar lemas, corolarios y teoremas que describan los comportamientos de las
    operaciones que queremos verificar y escribirlos en {\coq}, usando las definiciones inductivas
    descritas en el punto anterior.
    \item Por \', demostrar todos los enunciados del punto anterior utilizando las t\'acticas
    que el asistente de pruebas nos provee.
\end{itemize}{}

\subsection{Capturando invariantes de los {\Arns}}
Una de las etapas m\'as importantes al realizar la verificaci\'on formal en {\coq} de cualquier estructura de
datos, inclusive de cualquier programa, es capturar sus invariantes de manera correcta, es decir,
poder escribir una o varias definiciones inductivas que describan a la estructura de datos y sus
invariantes. Después, con estas mismas es que se enuncian los lemas, clases y posteriormente
instancias de las clases.

A continuaci\'on se describen dos conjuntos de definiciones inductivas, muy similares entre ellas,
los cuales nos ayudaran a verificar formalmente los {\arns}. La primera es un primer intento que es
insuficiente ya que los tipos inductivos y los principios de demostraci\'on no son los \'optimos.
El segundo intento es un conjunto de definiciones inductivas que tienen mas detalle para describir
los invariantes. Estas definiciones est\'an relacionadas con las propiedades de las operaciones de
inserci\'on y eliminaci\'on.

\subsubsection{Primer Conjunto de Definiciones Inductivas}
Los dos conjuntos de definiciones inductivas comparten la misma idea: una definici\'on que describe
estrictamente lo que es un {\arn} y otra definici\'on m\'as laxa de la misma.

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Inductive isRB : Tree -> color -> nat -> Prop :=
 | IsRB_leaf: forall c, isRB E c 0
 | IsRB_r: forall tl k kv tr n,
          isRB tl Red n ->
          isRB tr Red n ->
          isRB (T Red tl k kv tr) Black n
 | IsRB_b: forall c tl k kv tr n,
          isRB tl Black n ->
          isRB tr Black n ->
          isRB (T Black tl k kv tr) c (S n).
\end{minted}
\caption{Funci\'on inductiva isRB.}
\label{inductive_isRB}
\end{figure}

La primera definici\'on llamada $isRB$ (figura \ref{inductive_isRB}) tiene tres casos, los
cuales describiremos a continuaci\'on:
\begin{itemize}
        \item \textbf{IsRB\_Leaf}: el árbol vacío con altura negra 0 es roji-negro. En este caso
        se tiene un s\'olo nodo, es decir, una hoja\footnote{Recordemos que las hojas son vacias y de
        color negro.}.
        \item \textbf{IsRB\_r}: Para cualesquiera \'arboles \textbf{\textit{tl}} y \textbf{\textit{tr}} que cumplan con la
        definici\'on $isRB$ con color rojo y altura \textbf{\textit{n}}, se cumple que un \'arbol de color rojo con
        \textbf{\textit{tl}} y \textbf{\textit{tr}} como subarboles, sea \textbf{\textit{t}}, cumple con $isRB$ con color negro y altura \textbf{\textit{n}}. El
        color se refiere al color del padre, en este caso, en la llamada de $isRB$ a \textbf{\textit{tl}} y \textbf{\textit{tr}} se
        le pasa el color rojo porque \textbf{\textit{t}} es rojo. La altura \textbf{\textit{n}} se refiere a que hay \textbf{\textit{n}} nodos
        negros en cualquier camino del nodo actual a alguna hoja, aqui no crece \textbf{\textit{n}} porque tanto
        \textbf{\textit{tl}} y \textbf{\textit{tr}} son rojos.
        \item \textbf{IsRB\_b}: Para cualesquiera \'arboles \textbf{\textit{tl}} y \textbf{\textit{tr}} que cumplan con la
        definici\'on $isRB$ con color negro y altura \textbf{\textit{n}}, se cumple que un \'arbol de color negro
        con \textbf{\textit{tl}} y \textbf{\textit{tr}} como subarboles, sea \textbf{\textit{t}}, cumple con $isRB$ con cualquier color y altura
        $S(n)$. En este caso, en la llamada de $isRB$ a \textbf{\textit{tl}} y \textbf{\textit{tr}} se le pasa el color negro
        porque \textbf{\textit{t}} es negro y aqui se le suma uno a \textbf{\textit{n}} porque tanto \textbf{\textit{tl}} y \textbf{\textit{tr}} son negros.
\end{itemize}

Con estos tres casos podemos asegurar que los invariantes se respetan, pero esta funci\'on
inductiva es demasiado restrictiva y esto dificulta poder demostrar las propiedades de los {\arns},
por esto pasamos a la segunda definici\'on inductiva, $nearRB$, esta permite mas flexibilidad en el
\'arbol, se muestra y describe en la figura \ref{inductive_nearRB}.
%punto
\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Inductive nearRB : Tree -> nat -> Prop :=
| nrRB_r: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Red tl k kv tr) n
| nrRB_b: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Black tl k kv tr) (S n).
\end{minted}
\caption{Funci\'on inductiva nearRB.}
\label{inductive_nearRB}
\end{figure}

Podemos apreciar que solo se tienen dos casos y no se tiene un argumento para un color, sin
embargo, a diferencia de $isRB$ esta no se llama recursivamente, en lugar de eso se llama a $isRb$
inmediatamente, además podemos ver que ambas definiciones comparten el contador de nodos negros.
Con estas modificaciones se permite una cosa, que en la ra\'iz del \'arbol puedan haber a lo m\'as
dos nodos rojos contiguos.

\paragraph{Intento de Verificaci\'on}
Utilizando las funciones inductivas descritas en esta secci\'on se realiz\'o un intento fallido de
verificac\'on de la operaci\'on de inserci\'on, como se muestra en \cite{appel}, sin embargo, al
estar desarrollando la demostraci\'on se encontró un problema, la falta de un conjunto de
hipótesis para poder probar una meta. Esto se debe probablemente a una mala elección de estilo de
demostraci\'on, implementaci\'on o de las definiciones inductivas mostradas anteriormente. Se noto
que el hecho de que toda la informaci\'on referente a los invariantes estuviera codificada en las
dos funciones inductivas, sin uso de ``funciones auxiliares'' complica la verificaci\'on. Se
llego a esta conclusi\'on ya que el caso ``sencillo'' de la verificaci\'on de {\arns} es la inserci
\'on y con este conjunto de funciones inductivas las demostraciones se volvían muy largas y
complicadas de seguir.

\subsubsection{Segundo Conjunto de Definiciones Inductivas}

Con el conocimiento que se obtuvo del conjunto de definiciones anterior, nos realizamos la
siguiente pregunta: ¿c\'omo capturar las invariantes de los {\arns}, y al mismo tiempo facilitar la
verificaci\'on de estos?

Utilizamos una definición inductiva, llamada $is\_redblack$ para poder capturar los invariantes,
la cual lleva como parámetros un contador y un \'arbol. El contador lleva el control de la
cantidad de nodos negros, es decir, la altura negra del nodo, mientras que el \'arbol es aquel que
estamos buscando verificar que cumpla con las invariantes de un {\arn}. Se presenta esta definici\'
on en la figura \ref{inductive_isRedB}.

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Inductive is_redblack {a} `{GHC.Base.Ord a} : nat -> RB a -> Prop :=
 | RB_Leaf : is_redblack 0 E
 | RB_R n l k r : notred l -> notred r ->
                  is_redblack n l -> is_redblack n r ->
                  is_redblack n (T R l k r)
 | RB_B n l k r : is_redblack n l -> is_redblack n r ->
                  is_redblack (S n) (T B l k r).
\end{minted}
\caption{Funci\'on inductiva $is\_redblack$.}
\label{inductive_isRedB}
\end{figure}

Podemos notar ciertas similitudes con la definición inductiva de la secci\'on pasada, sin
embargo, el principal cambio que presenta esta definición, es el hecho de que se dejan de controlar
los colores de los subárboles en los parámetros de la definici\'on y se crea la funci\'on $notred$,
la cual, como su nombre dice, verifica que el \'arbol que se este pasando no tenga raíz roja. La
definici\'on $is\_redblack$ tiene tres casos,$RB\_Leaf$, $RB\_R$ y $RB\_B$. Desarrollando la idea de cada caso:

\begin{itemize}
        \item \textbf{RB\_Leaf}: el árbol vació es roji-negro. Este caso nos dice que el \'arbol
        vacío es un {\arn}.
        \item \textbf{RB\_R}: un árbol rojo donde lleves contados \textbf{\textit{n}} nodos negros, donde sus
        hijos sean{\arns} y no sean rojos. Este caso nos dice explícitamente que los subárboles
        del árbol que esta recibiendo la función no pueden ser rojos, esto porque el árbol que se
        esta analizando tiene raíz roja. Como no se esta analizando algún nodo negro, la altura
        negra se mantiene en \textbf{\textit{n}}.
        \item \textbf{RB\_B}: un árbol negro donde lleves contados $n+1$ nodos negros, incluido
        el actual, y sus hijos sean {\arns}. En este ultimo caso se tiene la libertad de que los
        subárboles sean del color que sea, pero la altura del consecuente es $S(n)$ porque el nodo
        que se esta analizando es de color negro, los antecedentes al no tomar en cuenta a su nodo
        padre tienen altura \textbf{\textit{n}}.
\end{itemize}

Esta definici\'on captura los invariantes que estamos buscando, sin embargo, no es suficiente para
poder probar la correcci\'on de los {\arns}, la definici\'on es demasiado restrictiva y costaría mucho
trabajo proceder con las demostraciones solamente con ella. Por esta razón se agregan dos
definiciones inductivas auxiliares; $redred\_tree$ y $nearly\_redblack$ (figura \ref{inductive_aux}).

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Inductive redred_tree {a}
                  `{GHC.Base.Ord a} (n:nat) : RB a -> Prop :=
 | RR_Rd l k r : is_redblack n l -> is_redblack n r
                                 -> redred_tree n (T R l k r).

Inductive nearly_redblack {a}
                  `{GHC.Base.Ord a} (n:nat)(t:RB a) : Prop :=
 | ARB_RB : is_redblack n t -> nearly_redblack n t
 | ARB_RR : redred_tree n t -> nearly_redblack n t.
\end{minted}
\caption{Funciones inductivas $redred\_tree$ y $nearly\_redblack$.}
\label{inductive_aux}
\end{figure}

Podemos notar que estas definiciones son versiones menos restrictivas de $is\_redblack$. La
definici\'on $nearly\_redblack$ permite que existan dos nodos rojos en la ra\'iz del \'arbol,
aprovech\'andose de $redred\_tree$, pues esta definici\'on es exactamente el caso $RB\_R$ de
$is\_redblack$ pero sin las restricciones de que los sub\'arboles sean rojos, lo cual nos permite
que hayan dos nodos rojos exactamente en la ra\'iz. Entonces un $nearly\_redblack$ es un {\arn} con
la excepci\'on de que la ra\'iz puede ser roja.

Finalmente, lo que se busca demostrar es que los {\arns} con las operaciones de inserci\'on y
eliminaci\'on est\'en dentro de la clase de \'arboles $redblack$ (figura \ref{class_rb}).

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Class redblack {a} `{GHC.Base.Ord a} (t:RB a) :=
                            RedBlack : exists d, is_redblack d t.
\end{minted}
\caption{Clase de \'arboles $redblack$.}
\label{class_rb}
\end{figure}

Lo que estamos describiendo con el enunciado de la figura \ref{class_rb} es que un {\arn} es aquel que tiene una altura
negra $d$ y cumple con las invariantes establecidas por la definici\'on $is\_redblack$.

\paragraph{Segundo Intento de Verificaci\'on}
En contraste con el conjunto de definiciones de la secci\'on pasada, la definici\'on de
$nearly\_redblack$ se reescribe, dejando de codificar las invariantes en las llamadas recursivas
de la definición, creando funciones auxiliares para capturar los invariantes de manera mas
sencilla, como $redred\_tree$ y $notred$. Además se crea la clase de {\arns}, lo cual afina mas la
definici\'on de los mismos. Tomando en cuenta todas estas modificaciones a las definiciones fue que
se eligió este conjunto para verificar formalmente la estructura de datos\footnote{La elecci\'on
de este conjunto fue correcta ya que facilito la demostraci\'on de las propiedades y probo ser
suficiente para verificar la estructura.}.
Estas definiciones inductivas fueron obtenidas de \cite{MSetRBT}.
