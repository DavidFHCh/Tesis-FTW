\chapter{Verificación formal de {\arns}}
Se menciono en el primer cap\'itulo de este trabajo que los {\arns} son una estructura de datos
que mejora el tiempo de acceso, de inserción y eliminación de elementos con respecto a otras
estructuras de datos, como las listas ligadas o doblemente ligadas. En el segundo cap\'itulo se
muestran las implementaciones delos algoritmos de esta  estructura de datos y podemos notar como
estas implementaciones no son triviales, es decir, son rebuscadas, enredosas y complicadas de
programar en un lenguaje del paradigma funcional comolo es {\coq}.
Por esta razón es que nos preocupa que las implementaciones que realicemos sean correctas y
completas, es decir, se desea verificar formalmente que las implementaciones de las operaciones
descritas en el capitulo anterior.

Para esto se usara, de igual manera, {\coq}. La verificaci\'on se divide en varios pasos:
\begin{itemize}
    \item Capturar los invariantes de los {\arns} usando definiciones inductivas en {\coq}, de
    esta manera podemos saber si las operaciones que se implementaron las respetan.
    \item Enunciar lemas, corolarios, teoremas que describan los comportamientos de las
    operaciones que queremos verificar y escribirlos en {\coq}.
    \item Por \'ultimo demostrar todos los enunciados del punto anterior utilizando el asistente
    de pruebas.
\end{itemize}{}

\section{Capturando invariantes de los {\Arns}}
Una de las partes mas importantes de la verificaci\'on formal de cualquier estructura de datos es
capturar sus invariantes de manera correcta, es decir, poder escribir una o varias definiciones
inductivas que describan a la estructura de datos y sus invariantes. Después, con estas
definiciones es que se enuncian los lemas, clases y posteriormente instancias de estas.

A continuaci\'on se describen dos conjuntos de definiciones inductivas, muy similares entre ellas,
para poder verificar formalmente esta estructura de datos. La primera es un primer intento que es
insuficiente ya que los tipos inductivos y los principios de demostraci\'on no son los \'optimos.
El segundo intento es un conjunto de definiciones inductivas que tienen mas detalle para describir
los invariantes. Estas definiciones est\'an relacionadas con las propiedades de las operaciones de
inserci\'on y eliminaci\'on.

\subsection{Primer Conjunto de Definiciones Inductivas}
Los dos conjuntos de definiciones inductivas comparten la misma idea; una definici\'on que
describa lo que es un {\arn} y otra definici\'on mas relajada de la misma.

La primera definici\'on, llamada $isRb$, esta definida de la siguiente manera:
\begin{minted}{coq}
Inductive isRB : Tree -> color -> nat -> Prop :=
 | IsRB_leaf: forall c, isRB E c 0
 | IsRB_r: forall tl k kv tr n,
          isRB tl Red n ->
          isRB tr Red n ->
          isRB (T Red tl k kv tr) Black n
 | IsRB_b: forall c tl k kv tr n,
          isRB tl Black n ->
          isRB tr Black n ->
          isRB (T Black tl k kv tr) c (S n).
\end{minted}
Esta definici\'on tiene tres casos, los describimos a continuaci\'on:
\begin{itemize}
        \item \textbf{IsRB\_Leaf} - el árbol vacío con altura negra 0 es roji-negro. En este caso
        si se tiene un solo nodo, es decir una hoja, la definici\'on cae en el caso $isRB_Leaf$.
        La altura negra siempre va a ser 0 ya que estas son nodos vacíos\footnote{estos nodos no
        tienen color pero para términos prácticos, se puede decir que son negros.}.
        \item \textbf{IsRB\_r} - un árbol rojo con altura negra $n$ y color negro, con hijos
        roji-negros con color rojo y altura negra $n$. En este segundo caso al recibir un \'arbol
        rojo, ninguno de sus hijos puede ser rojo, esto se enuncia haciendo que las llamadas
        recursivas de los antecedentes sean rojas y como no esta analizando ningún nodo negro la
        altura negra se conserva en $n$.
        \item \textbf{IsRB\_b} - un árbol negro con altura negra $n+1$ y cualquier color, con hijos
        roji-negros de altura $n$ y color negro. En este \'ultimo caso como recibimos un \'arbol
        de color negro la altura negra del consecuente es $S(n)$, también nos hace llamadas
        recursivas, en los antecedentes, con color negro, al pasar esto los nodos pueden ser tanto
        negros como rojos y la altura regresa a ser $n$ porque no se esta contando el nuevo nodo
        negro del consecuente.
\end{itemize}

Con estos tres casos podemos asegurar que las invariantes se respetan, pero esta funci\'on
inductiva es demasiado restrictiva para poder demostrar las propiedades de los {\arns}, por esto
pasamos a la segunda definici\'on inductiva, $nearRB$,  esta permite mas flexibilidad en el \'
arbol, se muestra y describe a continuaci\'on:

\begin{minted}{coq}
Inductive nearRB : Tree -> nat -> Prop :=
| nrRB_r: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Red tl k kv tr) n
| nrRB_b: forall tl k kv tr n,
         isRB tl Black n ->
         isRB tr Black n ->
         nearRB (T Black tl k kv tr) (S n).
\end{minted}
Podemos apreciar que solo se tienen dos casos y no se tiene un argumento para un color, sin
embargo, a diferencia de $isRB$ esta no se llama recursivamente, en lugar de eso se llama a $isRb$
inmediatamente, además podemos ver que ambas definiciones comparten el contador de nodos negros.
Con estas modificaciones se permite una cosa, que en la ra\'iz del \'arbol puedan haber a lo mas
dos nodos rojos contiguos.

\subsubsection{Intento de Verificaci\'on}
Utilizando las funciones inductivas descritas en esta secci\'on se realiz\'o un intento fallido de
verificac\'on de la operaci\'on de inserci\'on, como se muestra en \cite{appel}, sin embargo al
estar desarrollando la demostraci\'on se encontró un problema, la falta de un conjunto de
hipótesis para poder probar una meta. Esto se debe probablemente a una mala elección de estilo de
demostraci\'on, implementaci\'on o de las definiciones inductivas mostradas anteriormente. Se noto
que el hecho de que toda la informaci\'on referente a los invariantes estuviera codificada en las
dos funciones inductivas, sin uso de ``funciones auxiliares'', complica la verificaci\'on. Se
llego a esta conclusi\'on ya que el caso ``sencillo'' de la verificaci\'on de {\arns} es la inserci
\'on y con este conjunto de funciones inductivas las demostraciones se volvían muy largas y
complicadas de seguir.

\subsection{Segundo Conjunto de Definiciones Inductivas}

Con el conocimiento que se obtuvo del conjunto de definiciones anterior, nos realizamos la
siguiente pregunta: ¿como capturar las invariantes de los {\arns} y al mismo tiempo facilitar la
verificaci\'on de estos?

Utilizamos una definición inductiva, llamada $is\_redblack$ para poder capturar los invariantes,
la cual lleva como parámetros un contador y un \'arbol. El contador lleva el control de la
cantidad de nodos negros, es decir la altura negra del nodo, mientras que el \'arbol es aquel que
estamos buscando verificar que cumpla con las invariantes de un {\arn}. Se presenta esta definici\`
on a continuaci\'on:

\begin{minted}{coq}
Inductive is_redblack {a} `{GHC.Base.Ord a} : nat -> RB a -> Prop :=
 | RB_Leaf : is_redblack 0 E
 | RB_R n l k r : notred l -> notred r ->
                  is_redblack n l -> is_redblack n r ->
                  is_redblack n (T R l k r)
 | RB_B n l k r : is_redblack n l -> is_redblack n r ->
                  is_redblack (S n) (T B l k r).
\end{minted}

Podemos notar ciertas similitudes con la definición inductiva de las secci\'on pasada, sin
embargo, el
principal cambio que presenta esta definición es el hecho de que se saca el control de los colores
de los subárboles de los parámetros de la definici\'on y se crea la funci\'on $notred$, la cual,
como su nombre dice, verifique el \'arbol que se le este pasando no tenga raíz roja. Esta
definici\'on tiene tres casos,$RB\_Leaf$, $RB\_R$ y $RB\_B$. Desarrollando la idea de cada caso:

\begin{itemize}
        \item \textbf{RB\_Leaf} - el árbol vació es roji-negro. Este caso nos dice que el \'arbol
        vacío es un {\arn}.
        \item \textbf{RB\_R} - un árbol rojo donde lleves contados $n$ nodos negros, donde sus
        hijos sean{\arns} y no sean rojos. Este caso nos dice explícitamente que los subárboles
        del árbol que esta recibiendo la función no pueden ser rojos, esto porque el árbol que se
        esta analizando tiene raíz roja. Como no se esta analizando algún nodo negro, la altura
        negra se mantiene en $n$.
        \item \textbf{RB\_B} - un árbol negro donde lleves contados $n+1$ nodos negros, incluido
        el actual, y sus hijos sean {\arns}. En este ultimo caso se tiene la libertad de que los
        subárboles sean del color que sea, pero la altura del consecuente es $S(n)$ porque el nodo
        que se esta analizando es de color negro, los antecedentes al no tomar en cuenta a su nodo
        padre tienen altura $n$.
\end{itemize}

Esta definici\'on captura los invariantes que estamos buscando, sin embargo no es suficiente para
poder probar la correcci\'on de los {\arns}, esta es demasiado restrictiva y costaría mucho
trabajo proceder con las demostraciones solo con esta definici\'on. Por esta razón se agregan dos
definiciones inductivas auxiliares; $redred\_tree$ y $nearly\_redblack$:

\begin{minted}{coq}
Inductive redred_tree {a}
                  `{GHC.Base.Ord a} (n:nat) : RB a -> Prop :=
 | RR_Rd l k r : is_redblack n l -> is_redblack n r
                                 -> redred_tree n (T R l k r).

Inductive nearly_redblack {a}
                  `{GHC.Base.Ord a} (n:nat)(t:RB a) : Prop :=
 | ARB_RB : is_redblack n t -> nearly_redblack n t
 | ARB_RR : redred_tree n t -> nearly_redblack n t.
\end{minted}

Podemos notar que estas definiciones son versiones mas relajadas de $is\_redblack$. La
definici\'on $nearly\_redblack$ permite que existan dos nodos rojos en la ra\'iz del \'arbol,
aprovech\'andose de $redred\_tree$, pues esta definici\'on es exactamente el caso $RB\_R$ pero sin
las restricciones de que los sub\'arboles sean rojos, lo cual nos permite que hayan dos nodos
rojos exactamente en la ra\'iz. Entonces un $nearly\_redblack$ es un {\arn} con la excepci\'on de
que la ra\'iz puede ser roja.

Finalmente, lo que se busca demostrar es que los {\arns} con las operaciones de inserci\'on y
eliminaci\'on están dentro de la siguiente clase de arboles:

\begin{minted}{coq}
Class redblack {a} `{GHC.Base.Ord a} (t:RB a) :=
                            RedBlack : exists d, is_redblack d t.
\end{minted}

Lo que estamos describiendo con este enunciado es que un {\arn} es aquel que tiene una altura
negra $d$ y cumple con las invariantes establecidas por la definici\'on $is\_redblack$.

\subsubsection{Segundo Intento de Verificaci\'on}
En contraste con el conjunto de de definiciones de la secci\'on pasada, la definici\'on de
$nearly\_redblack$ se reescribe, dejando de codificar las invariantes en las llamadas recursivas
de la definición, creando funciones auxiliares para capturar los invariantes de manera mas
sencilla, como $redred\_tree$ y $notred$. Además se crea la clase de {\arns}, lo cual afina mas la
definici\'on de un {\arn}. Tomando en cuenta todas estas modificaciones a las definiciones fue que
se eligió este conjunto para verificar formalmente la estructura de datos\footnote{La elecci\'on
de este conjunto fue correcta ya que facilito la demostraci\'on de las propiedades y probo ser
suficiente para verificar la estructura.}.
Estas definiciones inductivas fueron obtenidas de \cite{MSetRBT}.
