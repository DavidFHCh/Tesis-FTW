\subsection{Verificación de la operación de eliminación}
Al igual que en la funci\'on de inserci\'on se enuncian lemas para ayudarnos a llegar al resultado
de verificar la operación de eliminación. Estos lemas giran en torno a las funciones auxiliares
que se usaron para poder demostrar la operación, como \hyperref[func_app]{$append$} y 
\hyperref[func_del]{$del$}.

A continuación se describe el razonamiento usado para poder verificar dichas funciones.

\subsubsection{Primer lema}


La funci\'on m\'as importante para la operaci\'on de eliminaci\'on es \hyperref[func_app]{$append$}, 
la cual concatena dos subárboles. Estos dos subárboles son el resultado de buscar, encontrar y 
eliminar un nodo. En este primer lema se enuncia lo antes descrito: que para cualesquiera dos 
\'arboles si estos cumplen con la definici\'on inductiva de 
\hyperref[inductive_isRedB]{$is\_redblack$}, ambos con altura $n$, el resultado de concatenar es 
casi un {\arn}, en otras palabras, la concatenaci\'on cumple con la definición de
\hyperref[inductive_isRedB]{$nearly\_redblack$}. Pero si los \'arboles que se van a concatenar 
además de cumplir con \hyperref[inductive_isRedB]{$is\_redblack$}, también cumplen con $notred$, es 
decir, las ra\'ices de dichos \'arboles no son rojas, el resultado de concatenar respeta también la 
definici\'on \hyperref[inductive_isRedB]{$is\_redblack$}. La demostracio\'on de este lema en {\coq} 
se describe en seguida:

\begin{minted}{coq}
______________________________________(1/1)
Forall (r : RB a) (n : nat),
  is_redblack n l
  -> is_redblack n r
    -> nearly_redblack n (append l r)
      /\ (notred l -> notred r -> is_redblack n (append l r))
\end{minted}

\begin{figure}[!ht]
  \centering
  \captionsetup{justification=centering}
  \begin{minted}{coq}
  Lemma append_arb_rb {a} `{GHC.Base.Ord a} (n:nat) (l r: RB a) :
  is_redblack n l -> is_redblack n r ->
  (nearly_redblack n (append l r)) /\
  (notred l -> notred r -> is_redblack n (append l r)).
  \end{minted}
  \caption{Lema $append\_arb\_rb$.}
  \label{lema_4}
  \end{figure}

En este primera etapa de la demostraci\'on podemos ver lo que se describió en el párrafo anterior.
Se decidió proseguir con esta demostraci\'on usando inducci\'on, primero sobre el árbol $l$ y
posteriormente sobre $r$. Los casos base de estas inducciones consisten en simplificación de las
expresiones y fácilmente se llega a una hipótesis o a una contradicci\'on. Estos casos no se
trataran m\'as a fondo en este trabajo, pasaremos directamente a los casos m\'as interesantes.



\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
______________________________________(1/4)
forall n : nat,
is_redblack n (T R ll lx lr)
-> is_redblack n (T R rl rx rr)
-> nearly_redblack n (append (T R ll lx lr) (T R rl rx rr))
/\ (notred (T R ll lx lr)
-> notred (T R rl rx rr)
-> is_redblack n (append (T R ll lx lr) (T R rl rx rr)))
______________________________________(2/4)
forall n : nat,
is_redblack n (T R ll lx lr)
-> is_redblack n (T B rl rx rr)
-> nearly_redblack n (append (T R ll lx lr) (T B rl rx rr))
/\ (notred (T R ll lx lr)
-> notred (T B rl rx rr)
-> is_redblack n (append (T R ll lx lr) (T B rl rx rr)))
______________________________________(3/4)
forall n : nat,
is_redblack n (T B ll lx lr)
-> is_redblack n (T R rl rx rr)
-> nearly_redblack n (append (T B ll lx lr) (T R rl rx rr))
/\ (notred (T B ll lx lr)
-> notred (T R rl rx rr)
-> is_redblack n (append (T B ll lx lr) (T R rl rx rr)))
______________________________________(4/4)
forall n : nat,
is_redblack n (T B ll lx lr)
-> is_redblack n (T B rl rx rr)
-> nearly_redblack n (append (T B ll lx lr) (T B rl rx rr))
/\ (notred (T B ll lx lr)
-> notred (T B rl rx rr)
-> is_redblack n (append (T B ll lx lr) (T B rl rx rr)))
\end{minted}
\caption{Casos del lema $append\_arb\_rb$.}
\label{casos_append}
\end{figure}

Esta doble inducci\'on nos deja con los siguientes cuatro casos, expuestos en la figura \ref{casos_append}:
\begin{itemize}
    \item Los \'arboles a concatenar son rojos.
    \item El \'arbol que se concatenar\'a a la izquierda es rojo y el derecho 
es negro.
    \item El \'arbol que se concatenar\'a a la izquierda es negro y el derecho 
es rojo.
    \item Los \'arboles a concatenar son negros.
\end{itemize}

En estos cuatro casos se cuida el hecho de no desbalancear el \'arbol, en otras palabras, 
que la altura negra sea la misma al terminar de la concatenaci\'on. Por eso es que se tiene cuidado
especial en los casos donde se manejan nodos negros, ya que \'estos son los únicos nodos
considerados para el balanceo.

En las siguientes subsecciones explicamos mas a fondo los pasos usados para probar estos casos.


\paragraph{Concatenaci\'on de dos \'arboles rojos.}

Este primer caso es la concatenaci\'on de dos \'arboles con raíces rojas, en el siguiente
fragmento de la salida del asistente de pruebas se observa c\'omo la meta es una conjunci\'on.

\begin{minted}{coq}
IHlr : forall (r : RB a) (n : nat),
    is_redblack n lr
     -> is_redblack n r
       -> nearly_redblack n (append lr r)
         /\ (notred lr -> notred r -> is_redblack n (append lr r))
IHrl : forall n : nat,
     is_redblack n (T R ll lx lr)
     -> is_redblack n rl
       -> nearly_redblack n (append (T R ll lx lr) rl)
         /\ (notred (T R ll lx lr)
            -> notred rl -> is_redblack n (append (T R ll lx lr) rl))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T R ll lx lr)
  -> is_redblack n (T R rl rx rr)
   -> nearly_redblack n (append (T R ll lx lr) (T R rl rx rr))
     /\ (notred (T R ll lx lr)
       -> notred (T R rl rx rr)
        -> is_redblack n (append (T R ll lx lr) (T R rl rx rr)))
\end{minted}

Podemos observar que la segunda parte de la conjunci\'on es una contradicci\'on, ya que al
introducir los antecedentes de la meta tendríamos lo siguiente:

\begin{minted}{coq}
H21 : notred (T R ll lx lr)
H22 : notred (T R rl rx rr)
______________________________________(1/1)
is_redblack n (append (T R ll lx lr) (T R rl rx rr))
\end{minted}

Evidentemente las dos funciones $notred$ de las hip\'otesis $H21$ y $H22$ se eval\'uan a falso y por
esto es una contradicci\'on.

Nos queda por demostrar la primera parte de la conjunci\'on. La meta de este caso, como se ve en
seguida, es que al ser concatenados un par de \'arboles rojos el árbol resultante cumple con la
definici\'on de ser de \hyperref[inductive_isRedB]{$nearly\_redblack$}, es decir, que la raíz del 
\'arbol puede tener dos nodos rojos consecutivos.

\begin{minted}{coq}
______________________________________(1/2)
nearly_redblack n (append (T R ll lx lr) (T R rl rx rr))
\end{minted}

El siguiente paso ser\'ia simplificar esta expresión, la cual cae en el caso de dos nodos rojos de la 
función \hyperref[func_app]{$append$} y nos resulta en la siguiente meta:

\begin{minted}{coq}
______________________________________(1/1)
redred_tree n
  match append lr rl with
  | T R lr' x rl' => T R (T R ll lx lr') x (T R rl' rx rr)
  | _ => T R ll lx (T R (append lr rl) rx rr)
  end
\end{minted}

Podemos ver que la caza de patrones depende de la evaluaci\'on de la expresi\'on $append(lr,rl)$,
digamos $rbt$, esto nos dar\'ia dos casos:

\begin{itemize}
    \item El primer caso, como se ve en seguida, se puede resolver usando las definiciones
    inductivas de \hyperref[inductive_isRedB]{$redred\_tree$} e 
    \hyperref[inductive_isRedB]{$is\_redblack$}, y las metas resultantes son resultados directos de 
    aplicar las hipótesis que se muestran.
    \begin{minted}{coq}
        H8 : notred lr
        H9 : is_redblack n ll
        H14 : notred rl
        H16 : notred rr
        H18 : is_redblack n rr
        H19 : nearly_redblack n E
        H20 : notred lr -> notred rl -> is_redblack n E
        H21 : redred_tree n E
        ______________________________________(1/2)
        redred_tree n (T R ll lx (T R E rx rr))
    \end{minted}
    \item El segundo caso es un poco m\'as complejo, pues se tienen que ver los casos en que $rbt$,
    resulta en un \'arbol con raíz roja y negra:
    \begin{itemize}
        \item En caso de que el \'arbol sea rojo, se aplica de igual manera las definiciones
        inductivas mencionadas en el caso anterior y las metas resultantes son implicaciones
        directas de las hipótesis que se muestran.
    \begin{minted}{coq}
    H6 : notred ll
    H9 : is_redblack n ll
    H14 : notred rl
    H16 : notred rr
    H20 : notred lr ->
          notred rl -> is_redblack n (T R r1_1 a0 r1_2)
    ______________________________________(1/1)
    redred_tree n (T R (T R ll lx r1_1) a0 (T R r1_2 rx rr))
    \end{minted}
        \item El caso donde el \'arbol es negro, al igual que en el caso pasado se hacen uso de
        las definicionces inductivas ya mencionadas y se siguen directamente de las siguientes
        hipótesis.
    \begin{minted}{coq}
    H6 : notred ll
    H8 : notred lr
    H9 : is_redblack n ll
    H10 : is_redblack n lr
    H14 : notred rl
    H16 : notred rr
    H17 : is_redblack n rl
    H18 : is_redblack n rr
    H19 : nearly_redblack n (T B r1_1 a0 r1_2)
    H20 : notred lr ->
          notred rl -> is_redblack n (T B r1_1 a0 r1_2)
    ______________________________________(1/1)
    redred_tree n (T R ll lx (T R (T B r1_1 a0 r1_2) rx rr))
    \end{minted}
    \end{itemize}
\end{itemize}

Con este procedimiento queda demostrado este caso de concatenar/unir dos \'aboles rojos con la 
funci\'on \hyperref[func_app]{$append$}. Se puede apreciar como los pasos de la demostraci\'on 
tienden a repetirse, esto puede significar que existan una serie de comandos y/o t\'acticas del 
asistente de pruebas que nos ayuden a acortar esta prueba. Sin embargo, en \'este trabajo se esta 
tomando el camino m\'as extenso para mostrar la simplificaci\'on de la l\'inea de pensamiento al 
demostrar estructuras complejas.

\paragraph{Concatenaci\'on de un \'arbol rojo y uno negro.}

Ahora es turno de analizar la demonstraci\'on del caso donde se concatena un \'arbol rojo y uno 
negro, es decir, $append(r,b)$, donde \textbf{\textit{r}} es un \'arbol rojo y \textbf{\textit{b}} es uno negro.

\begin{minted}{coq}
IHlr : forall (r : RB a) (n : nat),
     is_redblack n lr
     -> is_redblack n r
       -> nearly_redblack n (append lr r)
         /\ (notred lr -> notred r -> is_redblack n (append lr r))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T R ll lx lr)
  -> is_redblack n (T B rl rx rr)
   -> nearly_redblack n (append (T R ll lx lr) (T B rl rx rr))
     /\ (notred (T R ll lx lr)
       -> notred (T B rl rx rr)
        -> is_redblack n (append (T R ll lx lr) (T B rl rx rr)))
\end{minted}

En este segundo caso la conjunci\'on tambi\'en contiene una contradicci\'on en la mitad derecha de
\'esta, ya que se tiene \textit{notred (T R ll lx lr)}, entonces al igual que el caso pasado s\'olo
resolveremos la primera mitad de la conjunci\'on. Para esta demostración tenemos que guiar al 
asistente de pruebas un poco m\'as de lo normal, pues le tenemos que decirle que $r$ y el árbol 
\textit{(T B rl rx rr)} son el mismo.

\begin{minted}{coq}
r := T B rl rx rr : RB a
IHlr : forall n : nat,
     is_redblack n lr
     -> is_redblack n r
       -> nearly_redblack n (append lr r)
         /\ (notred lr -> notred r -> is_redblack n (append lr r))
n : nat
H1 : is_redblack n (T R ll lx lr)
H2 : is_redblack n r
______________________________________(1/1)
nearly_redblack n (T R ll lx (append lr r))
\end{minted}

Podemos observar que se realiz\'o una simplificaci\'on de la meta, donde se desarroll\'o lo mas
posible la funci\'on append y se introdujeron los antecedentes a las hip\'otesis. Para poder
demostrar esta nueva meta tenemos que destruir la hipótesis `IHlr', lo cual nos introduciría los
dos antecedentes de la misma como metas. Se destruye esta hipótesis para poder obtener su 
consecuente como hip\'otesis.

\begin{minted}{coq}
r := T B rl rx rr : RB a
IHlr : forall n : nat,
     is_redblack n lr
     -> is_redblack n r
       -> nearly_redblack n (append lr r)
         /\ (notred lr -> notred r -> is_redblack n (append lr r))
IHrl : forall n : nat,
     is_redblack n (T R ll lx lr)
     -> is_redblack n rl
       -> nearly_redblack n (append (T R ll lx lr) rl)
         /\ (notred (T R ll lx lr)
            -> notred rl -> is_redblack n (append (T R ll lx lr) rl))
n : nat
H1 : is_redblack n (T R ll lx lr)
H2 : is_redblack n r
______________________________________(1/3)
is_redblack n lr
______________________________________(2/3)
is_redblack n r
______________________________________(3/3)
nearly_redblack n (T R ll lx (append lr r))
\end{minted}

Para poder demostrar los dos primeros casos basta con aplicar la definici\'on inductiva
\hyperref[inductive_isRedB]{$is\_redblack$}, lo cual nos introduce las hipótesis necesarias para 
poder cumplir las metas.
Para el \'ultimo caso nos basta de igual manera con aplicar la misma definici\'on inductiva a H1 y
a la meta aplicar las definiciones de \hyperref[inductive_isRedB]{$nearly\_redblack$} y 
\hyperref[inductive_isRedB]{$redred\_tree$} y esto nos da metas, que gracias a las nuevas 
hip\'otesis integradas por H1, se pueden probar sin mayor problema.

Con esto demostrado este caso est\'a completo.

\paragraph{Concatenaci\'on de un \'arbol negro y uno rojo.}

En este caso se invierten los colores con respecto al caso anterior; el \'arbol derecho es rojo y
el izquierdo es negro. Este caso, al igual que el pasado, requiere de una pequeña ayuda al
asistente de pruebas, la cual explicaremos m\'as adelante.

\begin{minted}{coq}
IHlr : forall (r : RB a) (n : nat),
     is_redblack n lr
     -> is_redblack n r
       -> nearly_redblack n (append lr r)
         /\ (notred lr -> notred r -> is_redblack n (append lr r))
IHrl : forall n : nat,
     is_redblack n (T B ll lx lr)
     -> is_redblack n rl
       -> nearly_redblack n (append (T B ll lx lr) rl)
         /\ (notred (T B ll lx lr)
            -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T B ll lx lr)
  -> is_redblack n (T R rl rx rr)
    -> nearly_redblack n (append (T B ll lx lr) (T R rl rx rr))
      /\ (notred (T B ll lx lr)
         -> notred (T R rl rx rr)
           -> is_redblack n (append (T B ll lx lr) (T R rl rx rr)))
\end{minted}

En este caso al igual que los dos pasados, como uno\footnote{O los dos.} de los arboles es de
color rojo, la segunda parte de la conjunci\'on vuelve a ser una contradicci\'on, por la expresión
$notred$.

Entonces s\'olo nos quedamos con la primera mitad de la conjunci\'on:

\begin{minted}{coq}
l := T B ll lx lr : RB a
IHrl : forall n : nat,
     is_redblack n l
     -> is_redblack n rl
       -> nearly_redblack n (append l rl)
         /\ (notred l -> notred rl -> is_redblack n (append l rl))
n : nat
H1 : is_redblack n l
H2 : is_redblack n (T R rl rx rr)
______________________________________(1/2)
nearly_redblack n (T R (append l rl) rx rr)
\end{minted}

Podemos apreciar que este caso es el caso espejo del caso pasado, entonces el procedimiento a usar
para demostrar esta meta es el mismo, lo \'unico que cambia es cu\'ales hip\'otesis se usan para
lograr esto. En el caso pasado se destruy\'o la hip\'otesis IHlr, en este caso se usa su contraparte
IHrl y el resto de la demostraci\'on se sigue directamente de las nuevas metas introducidas y del
uso de las definiciones inductivas mencionadas en el caso pasado.

\paragraph{Concatenaci\'on de dos \'arboles negros.}

Este \'ultimo caso es el \'unico que no incluye una contradicci\'on ya que \'esta se
daba al tener un \'arbol rojo como uno de los dos \'arboles que se pasan a la funci\'on 
\hyperref[func_app]{$append$}, pero en este caso los dos \'arboles a concatenar son negros, entonces 
la conjunci\'on completa ser\'a probada.

\begin{minted}{coq}
IHlr : forall (r : RB a) (n : nat),
     is_redblack n lr
     -> is_redblack n r
       -> nearly_redblack n (append lr r)
         /\ (notred lr -> notred r -> is_redblack n (append lr r))
IHrl : forall n : nat,
     is_redblack n (T B ll lx lr)
     -> is_redblack n rl
       -> nearly_redblack n (append (T B ll lx lr) rl)
         /\ (notred (T B ll lx lr)
            -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T B ll lx lr)
  -> is_redblack n (T B rl rx rr)
    -> nearly_redblack n (append (T B ll lx lr) (T B rl rx rr))
      /\ (notred (T B ll lx lr)
         -> notred (T B rl rx rr)
           -> is_redblack n (append (T B ll lx lr) (T B rl rx rr)))
\end{minted}

Esta demostraci\'on se inicia con una inducci\'on sobre la altura negra, es decir, una inducción 
sobre $n$. Esto porque hacer la inducción sobre esta propiedad nos garantiza que el resultado de la 
concatenación no estará desbalanceado.

Esta inducci\'on nos da el caso base con $n=0$
, seguido de la separaci\'on de la conjunci\'on y esto nos da 2 casos base, como se muestra en
seguida:

\begin{minted}{coq}
IHlr : forall n : nat,
     is_redblack n lr
     -> is_redblack n rl
       -> nearly_redblack n (append lr rl)
         /\ (notred lr -> notred rl -> is_redblack n (append lr rl))
IHrl : forall n : nat,
     is_redblack n (T B ll lx lr)
     -> is_redblack n rl
       -> nearly_redblack n (append (T B ll lx lr) rl)
         /\ (notred (T B ll lx lr)
            -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
H1 : is_redblack 0 (T B ll lx lr)
H2 : is_redblack 0 (T B rl rx rr)
______________________________________(1/2)
nearly_redblack 0 (append (T B ll lx lr) (T B rl rx rr))
______________________________________(2/2)
notred (T B ll lx lr)
-> notred (T B rl rx rr)
  -> is_redblack 0 (append (T B ll lx lr) (T B rl rx rr))
\end{minted}

Estos casos base se resuelven aplicando las definiciones inductivas correspondientes tanto a las
metas como a las hip\'otesis H1 y H2, esto nos da las hipótesis necesarias para probar estos dos
casos.

Nos queda por probar el paso inductivo, en seguida podemos ver que la hipótesis de inducci\'on
`IH' es parte de IHlr, la cual se obtuvo de destruir esa hipótesis, en el siguiente paso se explica 
por qu\'e se decidió destruir esta hip\'otesis y no su contraparte IHrl.

\begin{minted}{coq}
IHlr : forall n : nat,
     is_redblack n lr
     -> is_redblack n rl
       -> nearly_redblack n (append lr rl)
         /\ (notred lr -> notred rl -> is_redblack n (append lr rl))
IHrl : forall n : nat,
     is_redblack n (T B ll lx lr)
     -> is_redblack n rl
       -> nearly_redblack n (append (T B ll lx lr) rl)
         /\ (notred (T B ll lx lr)
            -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
n : nat
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n (append lr rl)
______________________________________(1/1)
nearly_redblack (S n) (append (T B ll lx lr) (T B rl rx rr))
/\ (notred (T B ll lx lr)
   -> notred (T B rl rx rr)
     -> is_redblack (S n) (append (T B ll lx lr) (T B rl rx rr)))
\end{minted}

Proseguimos con la separaci\'on de la conjunci\'on, lo cual nos da dos casos que trabajaremos por
separado:

\paragraph{Primera mitad de conjunci\'on}

\begin{minted}{coq}
______________________________________(1/1)
nearly_redblack (S n) (append (T B ll lx lr) (T B rl rx rr))
\end{minted}

Después de simplificar la meta de este caso, nos queda una meta que depende del resultado de una
llamada recursiva a \hyperref[func_app]{$append$} de los subárboles $lr$ y $rl$, lo cual nos genera 
otros dos casos:

\begin{minted}{coq}
______________________________________(1/2)
is_redblack (S n) (lbalS ll lx (T B E rx rr))
______________________________________(2/2)
is_redblack (S n)
  match c with
  | R => T R (T B ll lx r1) a0 (T B r2 rx rr)
  | B => lbalS ll lx (T B (T c r1 a0 r2) rx rr)
  end
\end{minted}

Como podemos ver en ambas metas, tenemos una funci\'on nueva, \hyperref[lbalS]{$lbalS$}. Esta es una 
funci\'on de balanceo, la cual extiende a las funciones que ya se habían usado con anterioridad en la 
funci\'on de inserci\'on, como lo son \hyperref[rbal_2]{$rbal'$}, \hyperref[func_balanceo]{$rbal$} y 
\hyperref[func_balanceo]{$lbal$}.

Para poder resolver esta parte de la demostraci\'on nos apoyaremos de otro lema (figura
\ref{lema_5}), el cual ilustra una propiedad de la operaci\'on \hyperref[lbalS]{$lbalS$}.

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Lemma lbalS_rb {a} `{GHC.Base.Ord a}
(n : nat) (l : RB a) (x : a ) (r : RB a) :
nearly_redblack n l -> is_redblack (S n) r ->
              notred r -> is_redblack (S n) (lbalS l x r).
\end{minted}
\caption{Lema $lbalS\_rb$.}
\label{lema_5}
\end{figure}


Lo que el lema, arriba escrito en sintaxis de {\coq}, quiere decir es que si tenemos un par de
\'arboles, sean \textbf{\textit{l}} y \textbf{\textit{r}}, un n\'umero natural \textbf{\textit{n}} y
un elemento \textbf{\textit{x}}, si el \'arbol \textbf{\textit{l}} cumple con la
definici\'on inductiva \hyperref[inductive_isRedB]{$nearly\_redblack$} y \textbf{\textit{r}} no es de color rojo y 
cumple con la definici\'on inductiva \hyperref[inductive_isRedB]{$is\_redblack$}, entonces balancear 
estos dos arboles con \hyperref[lbalS]{$lbalS$} resulta en un {\arn} que cumple con la definici\'on 
$is\_redblack$.

La demostraci\'on de este lema se convierte en un análisis de casos en el cual solamente es
necesario simplificar, aplicar las definiciones inductivas y las metas que se generan son
consecuencias directas de las hipótesis generadas, la inducci\'on no es necesaria.

Regresando a las dos metas generadas por destruir la funci\'on \emph{append}, si nos fijamos en la primera,
podemos ver que se puede aplicar directamente el lema $lbalS_rb$, lo cual nos genera 3 nuevas 
metas:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n E
______________________________________(1/3)
nearly_redblack n ll
______________________________________(2/3)
is_redblack (S n) (T B E rx rr)
______________________________________(3/3)
notred (T B E rx rr)
\end{minted}

Estas metas de nuevo caen en el caso de simplificar y aplicar las respectivas definiciones
inductivas para obtener las metas deseadas, de esta manera el primer caso queda resuelto.

Ahora nos vamos al segundo caso generado al destruir la funci\'on \hyperref[func_app]{$append$} el 
cual nos dice que tenemos que hacer un análisis de casos sobre el color del nodo:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n (T R r1 a0 r2)
______________________________________(1/2)
is_redblack (S n) (T R (T B ll lx r1) a0 (T B r2 rx rr))
______________________________________(2/2)
is_redblack (S n) (lbalS ll lx (T B (T B r1 a0 r2) rx rr))
\end{minted}

Ese análisis de casos nos da dos metas nuevas, una por color. El primer caso solamente requiere
simplificaci\'on y aplicaci\'on de definiciones inductivas para obtener las metas deseadas. El
segundo caso sigue los mismos pasos con la única diferencia de volver a aplicar el lema 
\hyperref[lbalS]{$lbalS$}.

De esta manera queda demostrada la primera mitad de la conjunci\'on.

\paragraph{Segunda mitad de conjunci\'on}

\begin{minted}{coq}
______________________________________(1/1)
notred (T B ll lx lr)
-> notred (T B rl rx rr)
  -> is_redblack (S n) (append (T B ll lx lr) (T B rl rx rr))
\end{minted}

Esta segunda mitad sigue exactamente el mismo procedimiento antes descrito con la \'unica
diferencia de que se agregan hip\'otesis nuevas:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n (append lr rl)
H3 : notred (T B ll lx lr)
H4 : notred (T B rl rx rr)
______________________________________(1/1)
is_redblack (S n)
  match append lr rl with
  | T R lr' x rl' => T R (T B ll lx lr') x (T B rl' rx rr)
  | _ => lbalS ll lx (T B (append lr rl) rx rr)
  end
\end{minted}

Al hacer el análisis de casos destruyendo la funci\'on \hyperref[func_app]{$append$} con los 
par\'ametros $lr$ y $rl$, obtenemos exactamente las mismas metas que en la primera parte de la 
conjunci\'on y al tener mas hipótesis la demostraci\'on se acorta por un par de pasos pero el 
procedimiento es el mismo.

De esta manera queda demostrado el primer lema. A pesar de ser larga y
tediosa, se puede observar el poder del asistente de pruebas, ya que las demostraciones se reducen
a álgebra ecuacional, es decir, tratar de igualar la meta con lo que se tiene como hip\'otesis.
Esto se seguirá viendo en las siguientes pruebas.

\begin{figure}[!ht]
  \centering
  \captionsetup{justification=centering}
  \begin{minted}{coq}
  Lemma del_arb {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
        is_redblack (S n) s ->
        isblack s -> nearly_redblack n (del x s)
   with del_rb  {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
        is_redblack n s ->
        notblack s -> is_redblack n (del x s).
  \end{minted}
  \caption{Lema $del\_arb$}
  \label{lema_6}
  \end{figure}

\subsubsection{Segundo lema}
Este siguiente lema utiliza una palabra especial en el lenguaje de {\coq}, \emph{\textbf{with}}. Esta palabra
es un truco para demostrar dos lemas simultáneamente, el cual es el caso como se ve en la figura
\ref{lema_6}.

Como podemos ver, el lema en s\'i define dos lemas. Esto se hace de esta manera porque la
demostraci\'on de uno de estos lemas depende del otro. De esta manera podemos definir ambos lemas y
s\'olo usar una sola prueba.

\begin{minted}{coq}
  del_arb : forall (a : Type) (H : Base.Eq_ a) (H0 : Base.Ord a)
  (s : RB a) (x : a) (n : nat),
  is_redblack (S n) s ->
  isblack s -> nearly_redblack n (del x s)
  del_rb : forall (a : Type) (H : Base.Eq_ a) (H0 : Base.Ord a)
  (s : RB a) (x : a) (n : nat),
  is_redblack n s ->
  notblack s -> is_redblack n (del x s)
  ______________________________________(1/2)
  is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
  ______________________________________(2/2)
  is_redblack n s -> notblack s -> is_redblack n (del x s)
\end{minted}

Lo que el asistente de pruebas est\'a haciendo es que nos est\'a integrando al ambiente de hip\'otesis
los dos lemas. De esta manera podemos realizar suposiciones con \'estos y as\'i ayudarnos a demostrar
los lemas. Realizaremos las pruebas de estos lemas por separado.

\paragraph{Prueba de \hyperref[lema_6]{$del\_arb$}}

\begin{minted}{coq}
______________________________________(1/1)
is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
\end{minted}

Este lema enuncia lo siguiente: sea un \'arbol $s$, un elemento $x$ y un n\'umero natural $n$, si
$s$ cumple con la definicion inductiva \hyperref[inductive_isRedB]{$is\_redblack$} y $s$ es negro, 
entonces $s$ cumple con la definición de \hyperref[inductive_isRedB]{$nearly\_redblack$} después de 
eliminar el elemento $x$. En otras palabras, si tenemos un \'arbol con la raíz de color negro, el 
resultado de eliminar un elemento ser\'a un \'arbol casi rojinegro.

La prueba empieza con una inducci\'on sobre $s$ lo cual nos da las dos metas siguientes:
\begin{minted}{coq}
______________________________________(1/2)
forall n : nat, is_redblack (S n) E ->
                isblack E -> nearly_redblack n (del x E)
______________________________________(2/2)
forall n : nat,
  is_redblack (S n) (T c s1 a0 s2) ->
  isblack (T c s1 a0 s2) ->
  nearly_redblack n (del x (T c s1 a0 s2))
\end{minted}

A primera vista podemos apreciar que la primera meta contiene un antecedente falso ya que el \'arbol
vacío $E$ no puede ser negro, entonces esta meta es una contradicci\'on. La segunda meta podemos
ver que si analizamos los dos casos del color del \'arbol, el caso rojo es igualmente una
contradicci\'on por el mismo antecedente $isblack$. Esto s\'olo nos deja con el caso negro de la
segunda meta.

\begin{minted}{coq}
IHs1 : forall n : nat, is_redblack (S n) s1 ->
                       isblack s1 -> nearly_redblack n (del x s1)
IHs2 : forall n : nat, is_redblack (S n) s2 ->
                       isblack s2 -> nearly_redblack n (del x s2)
______________________________________(1/1)
forall n : nat,
is_redblack (S n) (T B s1 a0 s2)
-> isblack (T B s1 a0 s2) ->
nearly_redblack n (del x (T B s1 a0 s2))
\end{minted}

Después de introducir los antecedentes y simplificar la meta, se hace un análisis de casos sobre la
operaci\'on \hyperref[func_del]{$del$}, primero se ve el caso si el nodo a eliminar est\'a en el 
subárbol derecho y después en el izquierdo.

\begin{minted}{coq}
IHs1 : forall n : nat, is_redblack (S n) s1 ->
                       isblack s1 -> nearly_redblack n (del x s1)
IHs2 : forall n : nat, is_redblack (S n) s2 ->
                       isblack s2 -> nearly_redblack n (del x s2)
H1 : is_redblack (S n) (T B s1 a0 s2)
H2 : isblack (T B s1 a0 s2)
H6 : is_redblack n s1
H8 : is_redblack n s2
______________________________________(1/2)
nearly_redblack n
match s1 with
| T B _ _ _ => lbalS (del x s1) a0 s2
| _ => T R (del x s1) a0 s2
end
______________________________________(2/2)
nearly_redblack n
(if _GHC.Base.>_ x a0
 then
  match s2 with
  | T B _ _ _ => rbalS s1 a0 (del x s2)
  | _ => T R s1 a0 (del x s2)
  end
 else append s1 s2)
\end{minted}

Seguimos con el análisis de los dos casos:
\begin{itemize}
  \item En el primer caso seguimos con la destrucci\'on del \'arbol $s1$ para tener un análisis de
  casos, si simplificamos con las definiciones inductivas estas metas, eventualmente encontramos
  metas de las siguientes formas:
\begin{minted}{coq}
is_redblack n (del x E)

is_redblack n (del x (T R s1_1 a1 s1_2))
\end{minted}
  Estos casos son particulares del lema \hyperref[lema_6]{$del\_rb$}, para solucionar esto 
  usamos una táctica de {\coq} llamada $assert$, la cual nos deja agregar hip\'otesis, las cuales 
  después tendremos que demostrar, en este caso \'esta quedar'a demostrada al terminar de demostrar 
  todo este lema. Entonces como en este caso estamos destruyendo $s1$, la hip\'otesis a agregar 
  ser\'ia:
\begin{minted}{coq}
IHl' : forall n : nat, is_redblack n s1 ->
                  notblack s1 -> is_redblack n (del x s1)
\end{minted}
  Al agregarla al inicio de la prueba podemos solamente aplicarla cuando lleguemos a los casos
  arriba mencionados.
  \item El segundo caso se divide en dos, la primera parte es el caso espejo al pasado, se realiza 
  lo mismo pero para el \'arbol $s2$, lo cual nos da la siguiente hipótesis a agregar:
\begin{minted}{coq}
IHr' : forall n : nat, is_redblack n s2 ->
                  notblack s2 -> is_redblack n (del x s2)
\end{minted}
  Se aplica de la misma manera y llegamos a la segunda parte donde nos resulta la siguiente meta:
\begin{minted}{coq}
______________________________________(1/1)
nearly_redblack n (append s1 s2)
\end{minted}
  La cual es un caso particular del lema antes demostrado \hyperref[lema_4]{$append\_arb\_rb$}.
\end{itemize}

\paragraph{Prueba de \hyperref[lema_6]{$del\_rb$}}

\begin{minted}{coq}
______________________________________(1/1)
is_redblack n s -> notblack s -> is_redblack n (del x s)
\end{minted}

Este segundo lema enuncia lo siguiente: sea un \'arbol $s$, un elemento $x$ y un n\'umero natural
$n$, si $s$ cumple con la definicion inductiva \hyperref[inductive_isRedB]{$is\_redblack$} y $s$ no 
es negro, entonces $s$ cumple con la definición de \hyperref[inductive_isRedB]{$is\_redblack$} 
después de eliminar el elemento $x$. En otras palabras, si tenemos un \'arbol con la raíz de color 
rojo, el resultado de eliminar un elemento ser\'a un \'arbol casi rojinegro.

El enunciado con respecto al anterior busca que el resultado sea mas especifico, pues la propiedad
de ser \hyperref[inductive_isRedB]{$is\_redblack$} es la que buscamos que las operaciones cumplan. 
Sin embargo, la demostraci\'on en términos de {\coq} no es muy distinta; iniciamos con inducci\'on 
sobre s.

\begin{minted}{coq}
______________________________________(1/2)
forall n : nat, is_redblack n E ->
           notblack E ->
           is_redblack n (del x E)
______________________________________(2/2)
forall n : nat, is_redblack n (T c s1 a0 s2) ->
           notblack (T c s1 a0 s2) ->
           is_redblack n (del x (T c s1 a0 s2))
\end{minted}

La primera meta se soluciona simplificando hasta obtener la meta deseada, mientras que la segunda
meta se le hace un análisis sobre el color $c$, el cual arroja dos casos, rojo y negro. El caso de
que $c$ sea negro es una contradicci\'on porque no cumple con la meta de ser $notblack$, solamente
nos enfocaremos en el caso en que $c$ es rojo.

\begin{minted}{coq}
IHs1 : forall n : nat,
         is_redblack n s1 ->
         notblack s1 -> is_redblack n (del x s1)
IHs2 : forall n : nat,
         is_redblack n s2 ->
         notblack s2 -> is_redblack n (del x s2)
H1 : is_redblack n (T R s1 a0 s2)
H2 : notblack (T R s1 a0 s2)
______________________________________(1/1)
is_redblack n (del x (T R s1 a0 s2))
\end{minted}

Al igual que en \hyperref[lema_6]{$del\_arb$} se hacen los casos de si el elemento a eliminar est\'a 
en el subárbol derecho o izquierdo. Otra similitud que esta prueba tiene con respecto con la pasada 
es que también tenemos que agregar una hipótesis extra, en este caso de 
\hyperref[lema_6]{$del\_arb$}. De aquí en adelante la prueba es muy similar a la anterior, 
simplificar, aplicar definiciones inductivas hasta llegar a contradicciones o a las metas deseadas.

En este lema se usan lemas auxiliares muy similares a $lbalS\_rb$\footnote{Descrito en la prueba de
la  funci\'on \hyperref[func_app]{$append$}.}, como su espejo $rbalS\_rb$ o sus contrapartes 
$rbalS\_arb$ y $lbalS\_arb$. Estos son lemas de balanceo sencillos de demostrar pero muy largos, 
tediosos y repetitivos, por lo tanto no se incluirán en este trabajo\footnote{Se pueden consultar 
en: \url{https://github.com/DavidFHCh/Tesis-FTW}.}.

Hasta este momento s\'olo se han demostrado partes de la operación total de 
eliminación, como unir
dos subárboles despu\'es de eliminar su ra\'iz, qu\'e sucede si eliminamos de 
un árbol con raíz roja o
de uno con raíz negra. En seguida uniremos todos estos lemas en uno.

\subsubsection{Instancia de la funci\'on de eliminaci\'on}

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Instance remove_rb s x : redblack s -> redblack (remove x s).
\end{minted}
\caption{Instancia de eliminaci\'on de la clase \hyperref[class_rb]{$redblack$}.}
\label{instance_del}
\end{figure}


Al igual que en la funci\'on de inserción, terminamos la operación de eliminaci\'on generando una
instancia de la clase \hyperref[class_rb]{$redblack$} (figura \ref{instance_del}). Al igual que en la 
operación opuesta, requerimos de un lema auxiliar con respecto a la clase 
\hyperref[class_rb]{$redblack$} (figura \ref{lema_7}).

\begin{figure}[!ht]
\centering
\captionsetup{justification=centering}
\begin{minted}{coq}
Lemma makeBlack_rb {a} `{GHC.Base.Ord a} n t :
nearly_redblack n t -> redblack (makeBlack t).
\end{minted}
\caption{Lema $makeBlack\_rb$.}
\label{lema_7}
\end{figure}


Lo que este enunciado describe es la propiedad de que si un \'arbol $t$ cumple con la definici\'on
inductiva de ser \hyperref[inductive_isRedB]{$nearly\_redblack$}, pintar su raíz de color negro lo 
convierte en una instancia de la clase \hyperref[class_rb]{$redblack$}. La 
demostraci\'on de este 
lema es muy simple gracias al asistente de pruebas, ya que s\'olo basta con hacer un análisis de casos 
sobre el \'arbol $t$:

\begin{itemize}
  \item El \'arbol vac\'io $E$, la meta a demostrar para este caso es:
\begin{minted}{coq}
nearly_redblack n E -> redblack (makeBlack E)
\end{minted}
        Como la clase \hyperref[class_rb]{$redblack$} esconde un existencial en su definici\'on, 
        para poder demostrar este caso basta con decir que existe $n$ con valor 0, esto nos da un 
        caso trivial al ser la misma definici\'on inductiva de 
        \hyperref[inductive_isRedB]{$is\_redblack$}.
  \item El segundo caso se reduce a los dos casos en los que puede caer la definici\'on inductiva
  de \hyperref[inductive_isRedB]{$nearly\_redblack$}.
\begin{minted}{coq}
H1 : nearly_redblack n (T c t1 a0 t2)
H2 : is_redblack n (T c t1 a0 t2)
______________________________________(1/2)
redblack (makeBlack (T c t1 a0 t2))
\end{minted}
        Este primer caso se reduce a hacer un análisis de casos sobre el color $c$, la soluci\'on
        de ambos colores consiste en, decir que existe $n'$ tal que su valor es \textit{S(n)},
        después de esto se simplifican las expresiones hasta obtener que las metas cumplan con las
        hip\'otesis.
\begin{minted}{coq}
H1 : nearly_redblack n (T c t1 a0 t2)
H2 : redred_tree n (T c t1 a0 t2)
______________________________________(2/2)
redblack (makeBlack (T c t1 a0 t2))
\end{minted}
        El segundo caso es m\'as corto que el primero, ya que al hacer el análisis de los colores,
        podemos ver que la definición de \hyperref[inductive_isRedB]{$redred\_tree$} no est\'a 
        definida para \'arboles negros, entonces s\'olo nos queda demostrar para \'arboles rojos. Sin 
        embargo, los pasos a seguir para este caso son los mismos que para el color rojo del caso 
        anterior.
\end{itemize}

Con este lema demostrado ya contamos con todas las herramientas para poder 
demostrar que si tenemos a 
un \'arbol que es instancia de la clase \hyperref[class_rb]{$redblack$} y eliminamos un elemento de 
\'el, el \'arbol resultante sigue siendo instancia de la clase, esta 
demostraci\'on comienza con un análisis de casos 
sobre el \'arbol $s$:

\begin{minted}{coq}
H1 : is_redblack n E
______________________________________(1/2)
redblack (makeBlack (del x E))
______________________________________(2/2)
redblack (makeBlack (del x (T c s1 c0 s2)))
\end{minted}

Podemos ver que se hace uso de la funci\'on \hyperref[raiz_negra_func]{$makeBlack$}. En la primera 
meta basta con aplicar el lema $makeBlack\_rb$, simplificar y \'esta se soluciona. En la segunda meta 
se tiene que hacer otro an\'alisis de casos, esta vez sobre el color:

\begin{minted}{coq}
H1 : is_redblack n (T R s1 c0 s2)
______________________________________(1/2)
redblack (makeBlack (del x (T R s1 c0 s2)))

\end{minted}

En la primera meta, color rojo, comenzamos por aplicar $makeBlack\_rb$, el cual despu\'es de
simplificar con la definici\'on inductiva nos resulta en la siguiente meta:

\begin{minted}{coq}
H1 : is_redblack n (T R s1 c0 s2)
______________________________________(1/1)
is_redblack n (del x (T R s1 c0 s2))
\end{minted}

La cual es un caso particular del lema \hyperref[lema_6]{$del\_rb$}, nos basta con aplicarlo, 
simplificar y esta meta queda resuelta. La \'unica meta que nos quedaría por demostrar ser\'ia el caso 
de la raíz negra:

\begin{minted}{coq}
H1 : is_redblack n (T B s1 c0 s2)
______________________________________(1/1)
redblack (makeBlack (del x (T B s1 c0 s2)))
\end{minted}

En este caso hacemos un análisis sobre $n$, los dos casos ser\'ian 0 y \textit{S(n)}. Para 0 basta
con simplificar y la meta se resuelve, pero para \textit{S(n)}, es necesario volver a aplicar el
lema $makeBlack\_rb$, una vez que hacemos esto, nos queda la siguiente meta:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B s1 c0 s2)
______________________________________(1/1)
nearly_redblack n (del x (T B s1 c0 s2))
\end{minted}

La cual resulta ser un caso particular del lema \hyperref[lema_6]{$del\_arb$}, al aplicar este lema 
y simplificar nuevamente, las metas resultantes quedan resueltas. Podemos ver que las demostraciones 
cubiertas en este trabajo, en especial en la operaci\'on de eliminación, son muy repetitivas y s\'olo 
buscamos hacer que las metas empaten con las hip\'otesis que tenemos.

Con esta operaci\'on demostrada podemos decir que tenemos una estructura correcta respecto
a los invariantes descritos por las definiciones inductivas de 
\hyperref[inductive_isRedB]{$is\_redblack$} con las operaciones de borrado e inserción y de la misma 
manera que estas dos operaciones son métodos de la clase \hyperref[class_rb]{$redblack$}, por lo 
cual podemos hacer estas operaciones cuantas veces queramos y el resultado seguirá siendo instancia 
de esta clase.
