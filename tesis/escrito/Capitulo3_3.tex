\section{Verificación de la operación de eliminación}
Al igual que en la funci\'on de inserci\'on se enuncian lemas para ayudarnos a llegar al resultado
de verificar la operación de eliminación. Estos lemas giran en torno a las funciones auxiliares
que se usaron para poder demostrar la operación, como $append$ y $del$.

A continuación se describe el razonamiento usado para poder verificar dichas funciones.

\subsection{Primer Lema}
\begin{minted}{coq}
Lemma append_arb_rb {a} `{GHC.Base.Ord a} (n:nat) (l r: RB a) :
  is_redblack n l -> is_redblack n r ->
   (nearly_redblack n (append l r)) /\
   (notred l -> notred r -> is_redblack n (append l r)).
\end{minted}

La funci\'on mas importante para la operaci\'on de eliminaci\'on es $append$, la cual concatena
dos subarboles. Estos dos subarboles son el resultado de buscar, encontrar y eliminar un nodo. En
este primer lema se enuncia lo antes descrito: que para cualesquiera dos \'arboles si estos
cumplen con la definici\'on inductiva de $is\_redblack$, ambos con altura $n$, el resultado de
concatenar es casi un {\arn}, en otras palabras, la concatenaci\'on cumple con la definicion de
$nearly\_redblack$. Pero si los \'arboles que se van a concatenar ademas de cumplir con
$is\_redblack$, tambien cumplen con $notred$, es decir, las raices de dichos arboles no son rojas,
el resultado de concatenar respeta tambien la definici\'on $is\_redblack$. La demostracio\'on de
este lema en coq se describe en seguida:
\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
l : RB a
______________________________________(1/1)
Forall (r : RB a) (n : nat),
  is_redblack n l
  -> is_redblack n r
    -> nearly_redblack n (append l r)
      /\ (notred l -> notred r -> is_redblack n (append l r))
\end{minted}

En este primera etapa de la demostraci\'on podemos ver lo que se describio en el parrafo anterior.
Se decidio proseguir con esta demostraci\'on usando inducci\'on, primero sobre el arbol $l$ y
posteriormente sobre $r$. Los casos base de estas inducciones consisten en simplificacion de las
expresiones y facilmente se llega a una hipotesis o a una contradicci\'on. Estos casos no se
trataran mas a fondo en este trabajo, nos pasaremos directamente a los casos mas interesantes.

\begin{minted}{coq}
______________________________________(1/4)
forall n : nat,
  is_redblack n (T R ll lx lr)
  -> is_redblack n (T R rl rx rr)
    -> nearly_redblack n (append (T R ll lx lr) (T R rl rx rr))
      /\ (notred (T R ll lx lr)
         -> notred (T R rl rx rr)
           -> is_redblack n (append (T R ll lx lr) (T R rl rx rr)))
______________________________________(2/4)
forall n : nat,
  is_redblack n (T R ll lx lr)
  -> is_redblack n (T B rl rx rr)
    -> nearly_redblack n (append (T R ll lx lr) (T B rl rx rr))
      /\ (notred (T R ll lx lr)
         -> notred (T B rl rx rr)
           -> is_redblack n (append (T R ll lx lr) (T B rl rx rr)))
______________________________________(3/4)
forall n : nat,
  is_redblack n (T B ll lx lr)
  -> is_redblack n (T R rl rx rr)
    -> nearly_redblack n (append (T B ll lx lr) (T R rl rx rr))
      /\ (notred (T B ll lx lr)
         -> notred (T R rl rx rr)
           -> is_redblack n (append (T B ll lx lr) (T R rl rx rr)))
______________________________________(4/4)
forall n : nat,
  is_redblack n (T B ll lx lr)
  -> is_redblack n (T B rl rx rr)
    -> nearly_redblack n (append (T B ll lx lr) (T B rl rx rr))
      /\ (notred (T B ll lx lr)
         -> notred (T B rl rx rr)
           -> is_redblack n (append (T B ll lx lr) (T B rl rx rr)))
\end{minted}

Esta doble inducci\'on nos deja con cuatro casos, arriba expuestos, estos son los siguientes:
\begin{itemize}
    \item Los arboles a concatenar son rojos.
    \item El arbol que se concatenar a la izquierda es rojo y el derecho es negro.
    \item El arbol que se concatenar a la izquierda es negro y el derecho es rojo.
    \item Los arboles a concatenar son negros.
\end{itemize}

En estos cuatro casos se tiene que cuidar demasiado el hecho de no desbalancear el \'arbol, en
especial en los casos donde se manejan nodos negros, ya que estos son los unicos nodos
considerados para el balanceo.

En las siguientes subsecciones explicamos mas a fondo los pasos usados para probar estos casos.


\subsubsection{Concatenaci\'on de dos \'arboles rojos.}

Este primer caso es la concatenaci\'on de dos \'arboles con raices rojas, en el siguiente
fragmento de la salida del asistente de pruebas se observa como la meta es una conjunci\'on.

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
ll : RB a
lx : a
lr : RB a
IHlr : forall (r : RB a) (n : nat),
         is_redblack n lr
         -> is_redblack n r
           -> nearly_redblack n (append lr r)
             /\ (notred lr -> notred r -> is_redblack n (append lr r))
rl : RB a
rx : a
rr : RB a
IHrl : forall n : nat,
         is_redblack n (T R ll lx lr)
         -> is_redblack n rl
           -> nearly_redblack n (append (T R ll lx lr) rl)
             /\ (notred (T R ll lx lr)
                -> notred rl -> is_redblack n (append (T R ll lx lr) rl))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T R ll lx lr)
  -> is_redblack n (T R rl rx rr)
    -> nearly_redblack n (append (T R ll lx lr) (T R rl rx rr))
      /\ (notred (T R ll lx lr)
         -> notred (T R rl rx rr)
           -> is_redblack n (append (T R ll lx lr) (T R rl rx rr)))
\end{minted}

Podemos observar que la segunda parte de la conjunci\'on es una contradicci\'on, ya que al
introducir los antecedentes de la meta tendriamos lo siguiente:

\begin{minted}{coq}
H21 : notred (T R ll lx lr)
H22 : notred (T R rl rx rr)
______________________________________(1/1)
is_redblack n (append (T R ll lx lr) (T R rl rx rr))
\end{minted}

Evidentemente las dos funciones $notred$ de las hip\'otesis $H21$ y $H22$ se evaluan a falso y por
esto es una contradicci\'on.

Nos queda por demostrar la primera parte de la conjunci\'on, la meta de este caso, como se ve en
seguida, es que al ser concatenados un par de arboles rojos el arbol resultante cumple con la
definici\'on de ser de $nearly\_redblack$, es decir, que la raiz del \'arbol puede tener dos nodos
rojos consecutivos.

\begin{minted}{coq}
______________________________________(1/2)
nearly_redblack n (append (T R ll lx lr) (T R rl rx rr))
\end{minted}

El siguiente paso seria simplificar esta expresion, la cual cae en el caso de dos nodos rojos de la funcion $append$ y nos resulta en la siguiente meta:

\begin{minted}{coq}
______________________________________(1/1)
redred_tree n
  match append lr rl with
  | T R lr' x rl' => T R (T R ll lx lr') x (T R rl' rx rr)
  | _ => T R ll lx (T R (append lr rl) rx rr)
  end
\end{minted}

Podemos ver que la caza de patrones depende de la evaluaci\'on de la expresi\'on $append(lr,rl)$,
sea $rbt$, esto nos daria dos casos:

\begin{itemize}
    \item El primer caso, como se ve en seguida, se puede resolver usando las definiciones
    inductivas de $redred\_tree$ e $is\_redblack$, y las metas resultantes son resultados directos
    de aplicar las hipotesis que se muestran.
    \begin{minted}{coq}
        H8 : notred lr
        H9 : is_redblack n ll
        H14 : notred rl
        H16 : notred rr
        H18 : is_redblack n rr
        H19 : nearly_redblack n E
        H20 : notred lr -> notred rl -> is_redblack n E
        H21 : redred_tree n E
        ______________________________________(1/2)
        redred_tree n (T R ll lx (T R E rx rr))
    \end{minted}
    \item El segundo caso es un poco mas complejo, pues se tienen que ver los casos en que $rbt$,
    resulta en un \'arbol con raiz roja y negra:
    \begin{itemize}
        \item En caso de que el \'arbol sea rojo, se aplica de igual manera las definiciones
        inductivas mencionados en el caso anterior y las metas resultantes son implicaciones
        directas de las hipotesis que se muestran.
        \begin{minted}{coq}
        H6 : notred ll
        H9 : is_redblack n ll
        H14 : notred rl
        H16 : notred rr
        H20 : notred lr -> notred rl -> is_redblack n (T R r1_1 a0 r1_2)
        ______________________________________(1/1)
        redred_tree n (T R (T R ll lx r1_1) a0 (T R r1_2 rx rr))
        \end{minted}
        \item El caso donde el \'arbol es negro, al igual que en el caso pasado se hacen uso de
        las defincionces inductivas ya mencionadas y se siguen directamente de las siguientes
        hipotesis.
        \begin{minted}{coq}
        H6 : notred ll
        H8 : notred lr
        H9 : is_redblack n ll
        H10 : is_redblack n lr
        H14 : notred rl
        H16 : notred rr
        H17 : is_redblack n rl
        H18 : is_redblack n rr
        H19 : nearly_redblack n (T B r1_1 a0 r1_2)
        H20 : notred lr -> notred rl -> is_redblack n (T B r1_1 a0 r1_2)
        ______________________________________(1/1)
        redred_tree n (T R ll lx (T R (T B r1_1 a0 r1_2) rx rr))
        \end{minted}
    \end{itemize}
\end{itemize}

Con este procedimiento queda demostrado este caso de juntar dos \'aboles rojos con la funci\'on
$append$, se puede apreciar como los pasos de la demostraci\'on tienden a repetirse, esto puede
significar que existan una serie de comandos del asistente de pruebas que nos ayuden a acortar
esta prueba, sin embargo, en este trabajo se esta tomando el camino mas extenso para mostrar la
simplificaci\'on de la linea de pensamiento al demostrar estructuras complejas.

\subsubsection{Concatenaci\'on de un \'arbol rojo y uno negro.}

Ahora es turno de analizar la demonstraci\'on del caso donde se concatena un \'arbol rojo y uno negro, es decir, $append(r,b)$, donde r es un \'arbol rojo y b es uno negro.

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
ll : RB a
lx : a
lr : RB a
IHlr : forall (r : RB a) (n : nat),
         is_redblack n lr
         -> is_redblack n r
           -> nearly_redblack n (append lr r)
             /\ (notred lr -> notred r -> is_redblack n (append lr r))
rl : RB a
rx : a
rr : RB a
______________________________________(1/1)
forall n : nat,
  is_redblack n (T R ll lx lr)
  -> is_redblack n (T B rl rx rr)
    -> nearly_redblack n (append (T R ll lx lr) (T B rl rx rr))
      /\ (notred (T R ll lx lr)
         -> notred (T B rl rx rr)
           -> is_redblack n (append (T R ll lx lr) (T B rl rx rr)))
\end{minted}

En este segundo caso la conjunci\'on tambien contiene una contradicci\'on en la mitad derecha de
esta, ya que se tiene \textit{notred (T R ll lx lr)}, entonces al igual que el caso pasado solo
resolveremos la primera mitad de la conjunci\'on. Para esta demostracion tenemos que guiar al asistente de pruebas un poco mas de lo normal, pues le tenemos que decirle que $r$ y el arbol \textit{(T B rl rx rr)} son el mismo.

\begin{minted}{coq}
r := T B rl rx rr : RB a
IHlr : forall n : nat,
         is_redblack n lr
         -> is_redblack n r
           -> nearly_redblack n (append lr r)
             /\ (notred lr -> notred r -> is_redblack n (append lr r))
n : nat
H1 : is_redblack n (T R ll lx lr)
H2 : is_redblack n r
______________________________________(1/1)
nearly_redblack n (T R ll lx (append lr r))
\end{minted}

Podemos observar que se realizo una simplificaci\'on de la meta, donde se desarrollo lo mas
posible la funci\'on append y se intodujeron los antecedentes a las hip\'otesis. Para poder
demostrar esta nueva meta tenemos que destruir la hipotesis `IHlr', lo cual nos introduciria los
dos antecedendetes de la misma como metas. Se destruye esta hipotesis para poder obtener su consecuente como hip\'otesis.

\begin{minted}{coq}
r := T B rl rx rr : RB a
IHlr : forall n : nat,
         is_redblack n lr
         -> is_redblack n r
           -> nearly_redblack n (append lr r)
             /\ (notred lr -> notred r -> is_redblack n (append lr r))
IHrl : forall n : nat,
         is_redblack n (T R ll lx lr)
         -> is_redblack n rl
           -> nearly_redblack n (append (T R ll lx lr) rl)
             /\ (notred (T R ll lx lr)
                -> notred rl -> is_redblack n (append (T R ll lx lr) rl))
n : nat
H1 : is_redblack n (T R ll lx lr)
H2 : is_redblack n r
______________________________________(1/3)
is_redblack n lr
______________________________________(2/3)
is_redblack n r
______________________________________(3/3)
nearly_redblack n (T R ll lx (append lr r))
\end{minted}

Para poder demostrar los dos primeros casos basta con aplicar la definici\'on inductiva
$is\_redblack$, lo cual nos introduce las hipotesis necesarias para poder cumplir las metas.
Para el \'ultimo caso nos basta de igual manera con aplicar la misma definici\'on inductiva a H1 y
a la meta aplicar las definiciones de $nearly\_redblack$ y $redred\_tree$ y esto nos da metas, que
gracias a las nuevas hip\'otesis integradas por H1, se pueden probar sin mayor problema.

Con esto demostrado este caso esta completo.

\subsubsection{Concatenaci\'on de un \'arbol negro y uno rojo.}

En este caso se invierten los colores con respecto al caso anterior; el \'arbol derecho es rojo y
el izquierdo es negro. Este caso, al igual que el pasado, requiere de una pequeña ayuda al
asistente de pruebas, la cual explicaremos mas adelante.

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
ll : RB a
lx : a
lr : RB a
IHlr : forall (r : RB a) (n : nat),
         is_redblack n lr
         -> is_redblack n r
           -> nearly_redblack n (append lr r)
             /\ (notred lr -> notred r -> is_redblack n (append lr r))
rl : RB a
rx : a
rr : RB a
IHrl : forall n : nat,
         is_redblack n (T B ll lx lr)
         -> is_redblack n rl
           -> nearly_redblack n (append (T B ll lx lr) rl)
             /\ (notred (T B ll lx lr)
                -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T B ll lx lr)
  -> is_redblack n (T R rl rx rr)
    -> nearly_redblack n (append (T B ll lx lr) (T R rl rx rr))
      /\ (notred (T B ll lx lr)
         -> notred (T R rl rx rr)
           -> is_redblack n (append (T B ll lx lr) (T R rl rx rr)))
\end{minted}

En este caso al igual que los dos pasados, como uno\footnote{o los dos.} de los arboles es de
color rojo, la segunda parte de la conjunci\'on vuelve a ser una contradicci\'on, por la expresion
$notred$.

Entonces solo nos quedamos con la primera mitad de la conjunci\'on:

\begin{minted}{coq}
l := T B ll lx lr : RB a
IHrl : forall n : nat,
         is_redblack n l
         -> is_redblack n rl
           -> nearly_redblack n (append l rl)
             /\ (notred l -> notred rl -> is_redblack n (append l rl))
n : nat
H1 : is_redblack n l
H2 : is_redblack n (T R rl rx rr)
______________________________________(1/2)
nearly_redblack n (T R (append l rl) rx rr)
\end{minted}

Podemos apreciar que este caso es el caso espejo del caso pasdo, entonces el procedimiento a usar
para demostrar esta meta es el mismo, lo \'unico que cambia es cuales hip\'otesis se usan para
lograr esto. En el caso pasado se destruyo la hip\'otesis IHlr, en este caso se usa su contraparte
IHrl y el resto de la demostraci\'on se sigue directamente de las nuevas metas introducidas y del
uso de las definiciones inductivas mencionadas en el caso pasado.

\subsubsection{Concatenaci\'on de dos \'arboles negros.}

Este \'ultimo caso es el \'unico que no incluye una contradicci\'on ya que la contradicci'on se
daba al tener un \'arbol rojo como uno de los dos \'arboles que se pasan a la funci\'on $append$,
pero en este caso los dos \'arboles a concatenar son negros, entonces la conjunci\'on completa
ser\'a probada.

\begin{minted}{coq}
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
ll : RB a
lx : a
lr : RB a
IHlr : forall (r : RB a) (n : nat),
         is_redblack n lr
         -> is_redblack n r
           -> nearly_redblack n (append lr r)
             /\ (notred lr -> notred r -> is_redblack n (append lr r))
rl : RB a
rx : a
rr : RB a
IHrl : forall n : nat,
         is_redblack n (T B ll lx lr)
         -> is_redblack n rl
           -> nearly_redblack n (append (T B ll lx lr) rl)
             /\ (notred (T B ll lx lr)
                -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
______________________________________(1/1)
forall n : nat,
  is_redblack n (T B ll lx lr)
  -> is_redblack n (T B rl rx rr)
    -> nearly_redblack n (append (T B ll lx lr) (T B rl rx rr))
      /\ (notred (T B ll lx lr)
         -> notred (T B rl rx rr)
           -> is_redblack n (append (T B ll lx lr) (T B rl rx rr)))
\end{minted}

Esta demostraci\'on se inicia con una inducci\'on sobre $n$, lo cual nos da el caso base con $n=0$
, seguido de la separaci\'on de la conjunci\'on y esto nos da 2 casos base, como se muestra en
seguida:

\begin{minted}{coq}
IHlr : forall n : nat,
         is_redblack n lr
         -> is_redblack n rl
           -> nearly_redblack n (append lr rl)
             /\ (notred lr -> notred rl -> is_redblack n (append lr rl))
rx : a
rr : RB a
IHrl : forall n : nat,
         is_redblack n (T B ll lx lr)
         -> is_redblack n rl
           -> nearly_redblack n (append (T B ll lx lr) rl)
             /\ (notred (T B ll lx lr)
                -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
H1 : is_redblack 0 (T B ll lx lr)
H2 : is_redblack 0 (T B rl rx rr)
______________________________________(1/2)
nearly_redblack 0 (append (T B ll lx lr) (T B rl rx rr))
______________________________________(2/2)
notred (T B ll lx lr)
-> notred (T B rl rx rr)
  -> is_redblack 0 (append (T B ll lx lr) (T B rl rx rr))
\end{minted}

Estos casos base se resuelven aplicando las definiciones inductivas correspondientes tanto a las
metas como a las hip\'otesis H1 y H2, esto nos da las hipotesis necesarias para probar estos dos
casos.

Nos queda por probar el paso inductivo, en seguida podemos ver que la hipotesis de inducci\'on
`IH' es parte de IHlr, la cual se obtuvo de destruir esa hipotesis, en el siguiente paso se explica porque se decidio destruir esta hip\'otesis y no su contraparte IHrl.

\begin{minted}{coq}
IHlr : forall n : nat,
         is_redblack n lr
         -> is_redblack n rl
           -> nearly_redblack n (append lr rl)
             /\ (notred lr -> notred rl -> is_redblack n (append lr rl))
rx : a
rr : RB a
IHrl : forall n : nat,
         is_redblack n (T B ll lx lr)
         -> is_redblack n rl
           -> nearly_redblack n (append (T B ll lx lr) rl)
             /\ (notred (T B ll lx lr)
                -> notred rl -> is_redblack n (append (T B ll lx lr) rl))
n : nat
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n (append lr rl)
______________________________________(1/1)
nearly_redblack (S n) (append (T B ll lx lr) (T B rl rx rr))
/\ (notred (T B ll lx lr)
   -> notred (T B rl rx rr)
     -> is_redblack (S n) (append (T B ll lx lr) (T B rl rx rr)))
\end{minted}

Proseguimos con la separaci\'on de la conjunci\'on, lo cual nos da dos casos que trabajaremos por
separado:

\paragraph{Primera mitad de conjunci\'on}

\begin{minted}{coq}
______________________________________(1/1)
nearly_redblack (S n) (append (T B ll lx lr) (T B rl rx rr))
\end{minted}

Despues de simplificar la meta de este caso, nos queda una meta que depende del resultado de una
llamada recursiva a $append$ de los subarboles $lr$ y $rl$, lo cual nos genera otros dos casos:

\begin{minted}{coq}
______________________________________(1/2)
is_redblack (S n) (lbalS ll lx (T B E rx rr))
______________________________________(2/2)
is_redblack (S n)
  match c with
  | R => T R (T B ll lx r1) a0 (T B r2 rx rr)
  | B => lbalS ll lx (T B (T c r1 a0 r2) rx rr)
  end
\end{minted}

Como podemos ver en ambas metas, tenemos una funci\'on nueva, esta es una funci\'on de balanceo,
la cual extiende a las funciones que ya se habian usado con anterioridad en la funci\'on de inserci
\'on, como lo son $rbal'$, $rbal$ y $lbal$.

Para poder resolver esta parte de la demostraci\'on nos apoyaremos de otro lema, el cual ilustra
una propiedad de la operaci\'on $lbalS$:

\begin{minted}{coq}
Lemma lbalS_rb {a} `{GHC.Base.Ord a}
(n : nat) (l : RB a) (x : a ) (r : RB a) :
nearly_redblack n l -> is_redblack (S n) r ->
              notred r -> is_redblack (S n) (lbalS l x r).
\end{minted}

Lo que el lema, arriba escrito en sintaxis de coq, quiere decir es que si tenemos un par de
arboles, sean l y r, un n\'umero natural n y un elemento x, si el \'arbol $l$ cumple con la
definici\'on inductiva $nearly\_redblack$ y r no es de color rojo y cumple con la definici\'on
inductiva $is\_redblack$, entonces balancear estos dos arboles con $lbalS$ resulta en un {\arn}
que cumple con la definici\'on $is_redblack$.

Ls demostraci\'on de este lema se convierte en un analisis de casos en el cual solamente es
necesario simplificar, aplicar las definiciones inductivas y las metas que se generan son
consecuencias directas de las hipotesis generadas, la inducci\'on no es necesaria.

Regresando a las dos metas generadas por destruir la func\'on append, si nos fijamos en la primera
, podemos ver que se puede aplicar directamente el lema $lbalS$, lo cual nos genera 3 nuevas metas:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n E
______________________________________(1/3)
nearly_redblack n ll
______________________________________(2/3)
is_redblack (S n) (T B E rx rr)
______________________________________(3/3)
notred (T B E rx rr)
\end{minted}

Estas metas de nuevo caen en el caso de simplificar y aplicar las respectivas definiciones
inductivas para obtener las metas deseadas, de esta manera el primer caso queda resuelto.

Ahora nos vamos al segundo caso generado al destruir la funci\'on $append$ el cual nos dice que
tenemos que hacer un analisis de casos sobre el color del nodo:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n (T R r1 a0 r2)
______________________________________(1/2)
is_redblack (S n) (T R (T B ll lx r1) a0 (T B r2 rx rr))
______________________________________(2/2)
is_redblack (S n) (lbalS ll lx (T B (T B r1 a0 r2) rx rr))
\end{minted}

Ese analisis de casos nos da dos metas nuevas, una por color, el primer caso solamente requiere
simplificaci\'on y aplicaci\'on de definiciones inductivas para obtener las metas deseadas. El
segundo caso sigue los mismos pasos con la unica diferencia se volver a aplicar el lema $lbalS$.

De esta manera queda demostrada la primera mitad de la conjunci\'on.

\paragraph{Segunda mitad de conjunci\'on}

\begin{minted}{coq}
______________________________________(1/1)
notred (T B ll lx lr)
-> notred (T B rl rx rr)
  -> is_redblack (S n) (append (T B ll lx lr) (T B rl rx rr))
\end{minted}

Esta segunda mitad sigue exactamente el mismo procedimiento antes descrito con la \'unica
diferencia de que se agregan hip\'otesis nuevas:

\begin{minted}{coq}
H1 : is_redblack (S n) (T B ll lx lr)
H2 : is_redblack (S n) (T B rl rx rr)
IH : nearly_redblack n (append lr rl)
H3 : notred (T B ll lx lr)
H4 : notred (T B rl rx rr)
______________________________________(1/1)
is_redblack (S n)
  match append lr rl with
  | T R lr' x rl' => T R (T B ll lx lr') x (T B rl' rx rr)
  | _ => lbalS ll lx (T B (append lr rl) rx rr)
  end
\end{minted}

Al hacer el analisis de casos destruyendo la funci\'on $append$ con los parametros $lr$ y $rl$,
obtenemos exactamente las mismas metas que en la primera parte de la conjunci\'on y al tener mas
hipotesis la demostraci\'on se acorta por un par de pasos pero el procedimiento es el mismo.

De esta manera el primer lema queda demostrado, con esta demostraci\'on, a pesar de ser larga y
tediosa, se puede observar el poder del asistente de pruebas, ya que las demostraciones se reducen
a álgebra ecuacional, es decir, tratar de igualar la meta con lo que se tiene como hip\'otesis,
esto se seguira viendo en las siguientes pruebas.

\subsection{Segundo Lema}
Este siguiente lema utiliza una palabra especial en el lenguaje de {\coq}, `with', esta palabra
es un truco para demostrar dos lemas simultanemente, el cual es el caso como veremos en seguida:

\begin{minted}{coq}
Lemma del_arb {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
 with del_rb  {a} `{GHC.Base.Ord a} (s:RB a) (x:a) (n:nat) :
      is_redblack n s -> notblack s -> is_redblack n (del x s).
\end{minted}

Como podemos ver, el lema en si define dos lemas, esto se hace de esta manera porque la
demostraci\'on de uno de estos lemas depende del otro. De esta manera podemos definir ambos lemas y
solo usar una sola prueba.

\begin{minted}{coq}
del_arb : forall (a : Type) (H : Base.Eq_ a) (H0 : Base.Ord a)
        (s : RB a) (x : a) (n : nat),
        is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
del_rb : forall (a : Type) (H : Base.Eq_ a) (H0 : Base.Ord a)
        (s : RB a) (x : a) (n : nat),
        is_redblack n s -> notblack s -> is_redblack n (del x s)
a : Type
H : Base.Eq_ a
H0 : Base.Ord a
s : RB a
x : a
n : nat
______________________________________(1/2)
is_redblack (S n) s -> isblack s -> nearly_redblack n (del x s)
______________________________________(2/2)
is_redblack n s -> notblack s -> is_redblack n (del x s)
\end{minted}

Lo que el asistente de pruebas esta haciendo es que nos esta integrando al ambiente de hip\'otesis
los dos lemas, de esta manera podemos realizar suposiciones con estos y asi ayudarnos a demostrar
los lemas. Realizaremos las pruebas de estos lemas por separado.

\subsubsection{Prueba de $del\_arb$}
Este lema enuncia lo siguiente: Sea un \'arbol $s$, un elemento $x$ y un n\'umero natural $n$, si
el $s$ cumple con la definicion inductiva $is\_redblack$
\subsubsection{Prueba de $del\_rb$}

\subsection{Instancia de la funci\'on de eliminaci\'on}
\begin{minted}{coq}
Instance remove_rb s x : redblack s -> redblack (remove x s).
\end{minted}
