\chapter{Conclusiones}
Este trabajo busca ilustrar otra manera de demostrar la correcci\'on de una estructura de datos,
en este caso de un {\arn} usando un asistente de pruebas como lo es {\coq} con una biblioteca de
tipos y funciones que se tradujeron de Haskell.

Como ya hemos mencionado anteriormente otra opci\'on para realizar una prueba de este estilo seria
usar lapiz y papel, pero como vimos en los capitulos anteriores, pueden llegar a crearse demasiados
casos, esto lo vuelve una tarea muy complicada y tediosa de escribir, y posteriormente de leer y
entender por alguien mas. En cambio un asistente de pruebas como lo es {\coq} da herramientas para
simplificar esta tarea y logra reducirla a algebra ecuacional, ya que como se vio en este trabajo,
lo \'unico que se busca obtener es que las metas que queremos probar se igualen con alguna de las
hip\'otesis que se tienen.

Sin embargo, el uso de una herramienta de esta naturaleza por si sola no simplifica del todo estas
pruebas, ya que para poder llegar a un ecenario donde ya se puede desarrollar una prueba primero
tenemos que tener claro que es lo que se quiere probar y codificarlo en un lenguaje que la
herramienta comprenda.

En la vida real, esto significaria tener un programa escrito en algun leneguaje de programaci\'on
como Java, Python, Haskell, etc. y traducirlo al lenguaje de la herramienta. Esto requeriria la
implentaci\'on de dicho traductor o en su defecto traducir los programas a mano, esta segunda
siendo una soluci\'on no \'optima que es muy susceptible a errores. En este trabajo se uso el
traductor de Haskell a Coq llamado `hs-to-coq' \cite{thrc}, que aunque nos dio algunas bibliotecas
de Haskell traducidas a Coq, esta sigue en estado de desarrollo y aunque Haskell comparte el mismo
paradigma que el lenguaje de Coq,lograr traducir en un $100\%$ un lenguaje resulta muy complicado
ya que este siempre esta evolucionando, en especial si es un lenguaje tan ampliamentree usado como
lo es Haskell.

Otra restricci\'on que se tiene que establecer es que no todos los programas podrian ser traducidos
al lenguaje de la herramienta, si tomamos {\coq} como ejemplo, el lenguaje que usa es de un
paradigma funcional que solo acepta funciones totales. Entonces esto introduce otras problematicas,
la traducción un programa de un paradigma imperativo, l\'ogico, etc. a uno funcional y despues
asegurar que todas las funciones de este son totales.

Supongamos que resolvemos todos estos problemas que se han presentado hasta ahora, es decir,
tenemos un programa donde todas sus funciones son totales y se logro traducir correcta y
completamente. Ahora se tienen que generar las definiciones inductivas, las cuales te ayudaran a
guardar invariantes de tu programa, y con estas escribir los lemas que se buscan probar para poder
decir que tu programa es completo y correcto, lo cual podria tomar el mismo tiempo que tomo
traducir todo el programa al lenguaje de la herramienta.

Actualmente en la industria se busca que los programas que se escriben para uso del p\'ublico esten
``bien hechos'', es decir, que tengan la menor cantidad de errores y aunque la idea de poder probar
que un programa cualquiera puede ser probado formalmente usando un asistente de pruebas es muy
atractiva, esta resulta muy poco factible hoy en dia, ya que ademas de los problemas expuestos con
anterioridad se le suma el hecho de que se tendrian que traducir y probar \textbf{TODAS} las
bibliotecas del lenguaje que se esta usando, antes de pensar en probar tu programa.

Otro acercamiento para poder probar este tipo de programas para la industira seria desarrollar la
mayor parte de estos en el asistente {\coq}, con las herramientas que este posee se pueden realizar
las demostraciones pertinentes y utilizar una funcionalidad que este posee para extraer c\'odigo en
otros lengaujes como lo son Haskell y O'Caml. Sin embargo, esto solo nos permitiria desarrollar
programas correctos con las funcionalidades que el lenguaje de Coq ofrezca.

Esto nos deja con la conclusi\'on de que efectivamente, hoy en dia, Coq es un asitente de pruebas
que nos simplifica, hasta cierto punto, realizar demostraciones formales de programas si estamos
dispuestos a realizar traducciones y desarrollar mas bibliotecas para Coq, o a tener pequeños
modulos probados por Coq que pueden ser la principal columna de tu programa pero sin obtener una
cobertura total de pruebas.
