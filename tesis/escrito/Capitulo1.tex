\chapter{Introducción}

\section{Motivación}
\label{motivation}
Hoy en día en el desarrollo de software existe un conjunto de normas a las cuales se les denomina
\textit{buenas pr\'acticas de programaci\'on}, las cuales van desde tener una correcta
indentaci\'on, elegir si usaremos espacios o tabuladores para realizar este acomodo, la
documentaci\'on del c\'odigo, respetar las convenciones del lenguaje que estemos usado y probar
nuestro programa, en espec\'ifico, realizar pruebas unitarias.

Las \textit{pruebas unitarias} nos ayudan a saber si nuestro código esta teniendo el comportamiento
que buscamos, pero esto sol\'o nos sirve hasta cierto punto; por ejemplo, si tenemos una funci\'on
que recibe un par números naturales, para poder estar totalmente seguros de que la funci\'on es
correcta se tendrían que probar todos los casos, es decir, todas las combinaciones de números
naturales que existan, sin embargo, estas combinaciones son infinitas y se necesitaría la misma
cantidad de memoria y de tiempo para poder escribir una prueba unitaria exhaustiva, como la que se
esta sugiriendo. Teóricamente esto es posible, pero en la pr\'actica simplemente no contamos con los recursos suficientes.

Siendo as\'i, escribir una prueba unitaria exhaustiva no es factible, en tal caso ¿que podríamos
hacer?; escribir una prueba unitaria que itere sobre un conjunto representativo de los datos que la
funci\'on puede recibir como par\'ametros. Sin embargo, ¿si la misma prueba unitaria es errónea?,
no hay una respuesta clara para esto y la misma industria hoy en día utiliza métodos, como el
expuesto anteriormente, para probar su c\'odigo pero ciertamente esto no nos dice si el programa es
correcto o completo.

La única manera de que podamos probar que una función o programa es correcto y completo es mediante
una demostraci\'on matemática formal, el problema con este método es que es muy complejo y
complicado. A lo largo del tiempo se ha buscado la manera de hacer este proceso mas amigable al
programador, un ejemplo de esto son los lenguajes de programación funcionales, como lo seria Haskell. Este paradigma lleva
a los programas a un contexto donde la notaci\'on es muy parecida a lo que se usar\'ia en las
matemáticas tradicionales, es decir, funciones que van de un conjunto de datos a otro. Esto
facilita la demostraci\'on formal de los programas escritos en estos tipos de lenguajes, sin
embargo, estas demostraciones son realizadas de manera tradicional usando lap\'iz y hojas de papel,
no obstante, la \'unica manera de que estemos seguros de que nuestra desmostraci\'on es correcta es
que otra persona lea y entienda la misma. Todos estos procesos, creaci\'on y revisi\'on de la
demostraci\'on, estan hechos por humanos, por lo tanto son susceptibles a errores.

En los últimos años han entrado en desarrollando diversos programas que nos ayudan a solucionar
este tipo de problemas, como lo son \textit{demostradores autom\'aticos} y \textit{asistentes de
prueba}. Nosotros nos enfocaremos en el uso del segundo; en particular en este trabajo usaremos el
asistente de pruebas llamado {\coq}\footnote{Como en este trabajo no se profundizara sobre el funcionamiento de la herramienta, presentamos la pagina de referencia del mismo: \url{https://coq.inria.fr/}}. Este nos ayudar\'a gui\'andonos por la prueba, llevando un
control de los casos que nos falten por demostrar y las hip\'otesis disponibles para cada caso,
todo esto sobre programas escritos en el lenguaje funcional del mismo asistente.

Sin embargo, el uso de este asistente genera otro problema, no podemos probar cualquier programa
escrito en un lenguaje funcional, primero tenemos que traducir este programa al lenguaje de Coq
para poder comenzar con las demostraciones. Aquí tenemos dos opciones: traducir a mano o utilizar
una herramienta que nos ayude a traducir. En este trabajo usaremos la segunda opci\'on, el nombre
de la herramienta es `hs-to-coq' \cite{thrc}, lo que buscamos es lograr probar formalmente la
completud y correcci\'on de una estructura de datos como lo son los {\arns}.

En un trabajo anterior \cite{tesisG}, se realizaron diversas implementaciones de {\arns}, usando el
lenguaje de programaci\'on Haskell, se desarrollaron constructores inteligentes y una
implementaci\'on mas compleja usando tipos anidados. Siendo este trabajo la principal motivaci\'on
de elegir esta estructura de datos no trivial para realizar la demostraci\'on formal de su
corrección y completud.

\section{\Arns}
Los {\arns} son una estructura de datos donde sus operaciones de inserci\'on, eliminaci\'on y
búsqueda se efectúan en tiempo logarítmico, es decir, la complejidad de estas operaciones es:
$O(log(n))$. Los {\arns} son una subclase de los \'arboles binarios de búsqueda, en los cuales la
complejidad de dichas operaciones crece hasta $O(n)$, como si estos fueran una lista simple o
doblemente ligada. Esta mejora se obtiene gracias a la introducción de colores a los nodos del
\'arbol \footnote{Rojo y negro, de ahi rojinegros.} y a invariantes relacionados con estos, los
cuales describiremos en la siguiente definici\'on.

\subsection{Definici\'on de {\arns}}
Un \'arbol binario de búsqueda es un {\arn} si satisface lo siguiente:
\begin{enumerate}
    \item Todos sus nodos son rojos o negros.
    \item El \'arbol vac\'io es negro.
    \item La ra\'iz es negra \footnote{Dec\'imos que un \'arbol es negro o rojo si el nodo de la
    raiz es de ese color.}.
    \item Los siguientes invariantes se tienen que cumplir:
    \begin{itemize}
        \item Un nodo rojo debe tener hijos negros.
        \item Todos los caminos de la raíz a las hojas deben tener la misma cantidad de nodos
        negros.
        \item Todas las hojas del \'arbol son vacías y de color negro.
    \end{itemize}
\end{enumerate}

\begin{figure}
\centering
\captionsetup{justification=centering}
 \begin{tikzpicture}[-,level/.style={sibling distance = 5cm/#1,level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {$6_0$}
        child{ node [arn_r] {$2$}
            child{ node [arn_n] {$1_1$}
                child{ node [arn_x] {$x_2$}} %for a named pointer
                child{ node [arn_x] {$x_2$}}
            }
            child{ node [arn_n] {$4_1$}
                child{ node [arn_r] {$3$}
                    child{ node [arn_x] {$x_2$}}
                    child{ node [arn_x] {$x_2$}}
                }
                child{ node [arn_r] {$5$}
                    child{ node [arn_x] {$x_2$}}
                    child{ node [arn_x] {$x_2$}}
                }
            }
        }
        child{ node [arn_n] {$8_1$}
            child{ node [arn_x] {$x_2$}}
            child{ node [arn_r] {$9$}
                child{ node [arn_x] {$x_2$}}
                child{ node [arn_x] {$x_2$}}
            }
        }
;

\end{tikzpicture}
\caption {\Arn}
\label{arbolRB_1}
\end{figure}

En la figura \ref{arbolRB_1} podemos ver un ejemplo de un {\arn} que respeta la definici\'on que
acabamos de presentar; las etiquetas de los nodos representan la informaci\'on que se puede almacenar en ellos, siendo en este caso n\'umeros naturales, las letras $x$ en las hojas representan los nodos vacíos y estos
son negros, y los subíndice de estas etiquetas representan la altura negra de este \'arbol.
Con este ejemplo se ilustra como la cantidad de nodos negros de la ra\'iz a cualquier hoja es
siempre la misma.

Nos interesa estudiar este tipo no trivial de \textit{\'arboles binarios de búsqueda} para poder
demostrar la correcci\'on y completud de estos usando el asistente de pruebas {\coq} y de esta
manera poder mostrar las ventajas y desventajas de este proceso; el cual comienza escribiendo de
cero una estructura o traduciendo la misma del lenguaje Haskell a Coq, e incluso hasta las
demostraciones que se realizar\'an con el asistente de pruebas.

\section{Traducción de Haskell a Coq}
El enfoque que hemos decidido darle a este trabajo, consiste en considerar una implementaci\'on de la estructura descrita en la secci\'on pasada y solamente realizar la verificaci\'on formal de la misma, es por esta raz\'on que como mencionamos en la secci\'on \ref{motivation} de este trabajo, existen programas que nos ayudan a realizar la
verificaci\'on formal de otros programas, llamados asistentes de pruebas, en particular en este
trabajo se decidió usar {\coq}. Este asistente nos gu\'ia a traves de la prueba recordando cuales
son las metas que debemos demostrar, nos ofrece `t\'acticas' para poder demostrar dichas metas
entre otras cosas, sin embargo, esta tambi\'en nos presenta nuevos desaf\'ios.

Al comenzar a utilizar el asistente nos encontramos con las primeras problem\'aticas, estas
consisten es si vamos a escribir el programa directamente en el lenguaje de {\coq} o si lo que
buscamos es traducir un programa ya existente al lenguaje del asistente de pruebas; como lo que se
busca es poder verificar un programa antes escrito, es decir, los {\arns}, queremos poder traducir
este código de Haskell a {\coq}.

En el articulo `Total Haskell is Reasonable Coq' \cite{thrc} se describen las principales ventajas
y desventajas de traducir de Haskell a Coq, los cuales expondremos a continuaci\'on.

\subsection{Ventajas}
\begin{itemize}
    \item Haskell es un excelente lenguaje para escribir programas funcionales puros.
    \item La gran comunidad de programadores que usan y mantienen el lenguaje.
    \item El compilador GHC de Haskell, el cual tiene usos incluso industriales.
    \item El ambiente de Coq para desarrollar demostraciones formales.
    \item Coq permite razonar acerca de programas funcionales totales.
\end{itemize}

\subsection{Desventajas}
\begin{itemize}
    \item Se utiliza el razonamiento ecuacional, por lo que en general no se usa un lenguaje formal para realizar las demostraciones.
    \item Los programadores de Haskell razonan acerca de su código informalmente, si se llegan a
    realizar pruebas de este, generalmente esta hecho a mano ``en papel'', lo cual es tedioso y
    susceptible a errores.
    \item Coq no tiene la extensa biblioteca de funciones ni la misma cantidad de programadores
    que lo usen y mantengan como lo tiene Haskell.
    \item El hecho de que los programadores de Haskell s\'olo razonen acerca de su código
    informalmente puede que resulte en que se generen funciones parciales, es decir, que no se
    cubran todas la combinaciones de parámetros posibles para una funci\'on.
    \item La traducci\'on de Haskell a Coq s\'olo es posible si todas las funciones a traducir son
    totales.
\end{itemize}

Este art\'iculo propone el uso de una herramienta llamada \textit{hs-to-coq}, la cual actualmente se
encuentra en etapa de desarrollo y est\'a siendo usada para traducir código de Haskell a Coq. Por las razones expuestas al comienzo de esta secci\'on es que decidimos usar esta herramienta de traducci\'on y enfocarnos \'unicamente en la demostraci\'on de los \arns

\section{Sobre este trabajo}
El contenido y demostraciones que se describen en este trabajo se encuentran almacenados en:
\url{https://github.com/DavidFHCh/Tesis-FTW}. Aqu\'i presentamos definiciones, lemas y clases sin
incluir las demostraciones en {\coq}, en otras palabras, los scripts de prueba. En su lugar se describen de manera informal las demostraciones para poder entender en alto nivel la estructura de la verificaci\'on formal realizada.

En este trabajo se opto por usar el traductor \textit{hs-to-coq}, ya que la traducci\'on manual
resultaria ser muy tediosa y esta es susceptible a errores, tambi\'en se desviaría el enfoque de
este trabajo, el cual es la verificaci\'on de la estructura, no la traducci\'on de la misma. La
herramienta fue utilizada para obtener las traducciones de las bibliotecas de Haskell; estas fueron
usadas para poder verificar la implementación de {\arns} \cite{MSetRBT} que se uso en el trabajo.

En los siguientes capítulos se describe el procedimiento usado para la verificaci\'on de la
estructura de datos, al igual que las implementaciones y las pruebas realizadas para poder obtener
el resultado que se busca, i.e. la verificación formal de la estructura de datos.
