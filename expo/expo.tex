%%% Presentaciones para Lenguajes de programacion y sus paradigmas

\documentclass[xcolor=dvipsnames,table,handout]{beamer}
%\documentclass[xcolor=dvipsnames,table]{beamer}
%\documentclass[xcolor=dvipsnames,table,spanish]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

%%%% paquetes matematicas
\usepackage{amssymb,amsmath,amscd}
\usepackage{extarrows}
\usepackage{stmaryrd}
\usepackage{mathabx}
\usepackage{mathrsfs}
% \usepackage{mathabx}
\usepackage{amsthm}

%%%%%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{xcolor}
\usepackage{etex}
\usepackage{tikz}
\usepackage{array}
\usepackage{listings}
%\usepackage{pgfplots}


\newtheorem{prop}{Proposición}

%%%% cosmetics
% D.Remy package for pretty display of rules
\usepackage{mathpartir}

% para insertar codigo con formato particular
\usepackage{listings}
% lstlisting Haskell style (inspired from a file of Assia Mahboubi)
%
\lstdefinelanguage{Haskell}{
%
% Anything betweeen $ becomes LaTeX math mode
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false,
%
morekeywords=[1]{class, instance},
%
morekeywords=[2]{where},
%
morekeywords=[3]{Maybe},
%
morekeywords=[4]{main},
%
morekeywords=[6]{do, last, first, try, idtac, repeat},
%
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d],
%
% Size of tabulations
tabsize=3,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
breaklines=false,
%
% Default style fors listings
basicstyle=\small,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{dkviolet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{dkgreen}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{ltblue}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{dkblue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{dkred}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{dkgreen}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {->}{{$\rightarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\\dollar}{{$\$$\;}}1
%
}[keywords,comments,strings]

\lstnewenvironment{haskell}{\lstset{language=Haskell}}{}

% lstlisting coq style (inspired from a file of Assia Mahboubi)
%
\lstdefinelanguage{Coq}{
%
% Anything betweeen $ becomes LaTeX math mode
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false,
%
% Vernacular commands
morekeywords=[1]{Section, Module, End, Require, Import, Export,
  Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
  Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
  Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
  Morphism, Relation, Implicit, Arguments, Unset, Contextual,
  Strict, Prenex, Implicits, Inductive, CoInductive, Record,
  Structure, Canonical, Coercion, Context, Class, Global, Instance,
  Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
  Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
  Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
  Projections, inside, outside, Def},
%
% Gallina
morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
  match, with, end, as, in, return, let, if, is, then, else, for, of,
  nosimpl, when},
%
% Sorts
morekeywords=[3]{Type, Prop, Set, true, false, option},
%
% Various tactics, some are std Coq subsumed by ssr, for the manual purpose
morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
  intro, intros, generalize, rename, pattern, after, destruct,
  induction, using, refine, inversion, injection, rewrite, congr,
  unlock, compute, ring, field, fourier, replace, fold, unfold,
  change, cutrewrite, simpl, have, suff, wlog, suffices, without,
  loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
  symmetry, transitivity, auto, split, left, right, autorewrite},
%
% Terminators
morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
  assumption, solve, contradiction, discriminate},
%
% Control
morekeywords=[6]{do, last, first, try, idtac, repeat},
%
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d],
%
% Size of tabulations
tabsize=3,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
breaklines=false,
%
% Default style fors listings
basicstyle=\small,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{dkviolet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{dkgreen}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{ltblue}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{dkblue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{dkred}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{dkgreen}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
%    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1
    {\\o}{{$\circ\;$}}1
    {\@}{{$\cdot$}}1
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
%
}[keywords,comments,strings]

\lstnewenvironment{coq}{\lstset{language=Coq}}{}

% pour inliner dans le texte
\def\coqe{\lstinline[language=Coq, basicstyle=\small]}
% pour inliner dans les tableaux / displaymath...
\def\coqes{\lstinline[language=Coq, basicstyle=\scriptsize]}

%%% Local Variables:
%%% mode: latex
%%% Local IspellDict: british
%%% TeX-master: "main.tex"
%%% End:

\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.1,0.6}
\definecolor{dkgreen}{rgb}{0,0.35,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.5,0,0}

% comillas
\usepackage[autostyle=true,spanish=mexican]{csquotes}

% codigo
\usepackage{verbatim}
\usepackage{alltt}

% footnotes
\usepackage[bottom]{footmisc}
\usepackage{setspace}

\usepackage{wrapfig}
\usepackage{caption}


\hfuzz=5.002pt %parameter to allow hbox overfulled by length before error!

% Options for presentation
% ------------------------
% \definecolor{mycolor}{RGB}{255,192,3}
\definecolor{mycolor}{RGB}{17,132,221}
\mode<presentation>
{
% \usetheme[secheader]{Boadilla}
% \usecolortheme{orchid}
\useoutertheme{infolines}
\useinnertheme{rectangles}
\setbeamertemplate{itemize items}[square]
\setbeamertemplate{enumerate items}[square]
\setbeamersize{text margin left=6mm, text margin right=6mm}

\setbeamercolor{alerted text}{fg=red,bg=red!70!white}
\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{frametitle}{bg=mycolor,fg=white}
\setbeamercolor{normal text}{bg=white,fg=black}
\setbeamercolor{structure}{bg=black,fg=mycolor}
\setbeamercolor{title}{bg=mycolor,fg=white}
\setbeamercolor{subtitle}{bg=mycolor,fg=white}
\setbeamercolor{titlelike}{bg=white,fg=mycolor}

\setbeamercovered{invisible}

\setbeamercolor*{palette primary}{fg=mycolor,bg=white}
\setbeamercolor*{palette secondary}{bg=white,fg=white}
\setbeamercolor*{palette tertiary}{fg=mycolor,bg=white}
\setbeamercolor*{palette quaternary}{fg=white,bg=white}

\setbeamercolor{separation line}{bg=mycolor,fg=mycolor}
\setbeamercolor{fine separation line}{bg=white,fg=red}
\setbeamercolor{author in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{title in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{date in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{institute in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{section in head/foot}{bg=mycolor!60!white, fg=white}
\setbeamercolor{subsection in head/foot}
{bg=mycolor!50!white,fg=mycolor!50!white}


\setbeamertemplate{headline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.65ex,dp=1.5ex,center]{section in
head/foot}%
    \usebeamerfont{section in head/foot}\insertsectionhead\hspace*{2ex}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.65ex,dp=1.5ex,center]{subsection
in head/foot}%
    \usebeamerfont{subsection in head/foot}\hspace*{2ex}\insertsubsectionhead
  \end{beamercolorbox}}%
  \vskip0pt%
}
% \beamerdefaultoverlayspecification{<+->}
\beamertemplatenavigationsymbolsempty
% \setbeamertemplate{footline}[frame number]
}

\input{macroslc}

\title[]{Verificación formal de arboles rojinegros \\ en Haskell con Coq}
\author[David Hernández Chiapa]{David Felipe Hernández Chiapa \\
    \small{\texttt{davifep.96@gmail.com}}}
\institute[UNAM-FC]{Facultad de Ciencias \\
Universidad Nacional Aut\'onoma de M\'exico \\ \small{Proyecto
PAPIME PE102117}}
\date[]{\small{7 de diciembre de 2018}}


\beamerdefaultoverlayspecification{<+->}

\titlegraphic{\includegraphics[width=16mm]{fc2.png}
}

% Opciones extras
% L5: beamer en español
\usepackage[all]{xy}
\decimalpoint
% Counter para enumerates en varios frames
\newcounter{saveenumi}
\newcommand{\savei}{\setcounter{saveenumi}{\value{enumi}}}
\newcommand{\conti}{\setcounter{enumi}{\value{saveenumi}}}
\resetcounteronoverlays{saveenumi}
\definecolor{light-gray}{gray}{0.75}
\newcommand{\IF}{\operatorname{if}}
\newcommand{\THEN}{\operatorname{then}}
\newcommand{\ELSE}{\operatorname{else}}
\newcommand{\qn}{\operatorname{qn}}
\newcommand{\shift}{\operatorname{shift}}

\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{
<-6> mathb5 <6-7> mathb6 <7-8> mathb7
<8-9> mathb8 <9-10> mathb9
<10-12> mathb10 <12-> mathb12
}{}
\DeclareSymbolFont{mathb}{U}{mathb}{m}{n}
\DeclareMathSymbol{\llcurly}{\mathrel}{mathb}{"CE}
\DeclareMathSymbol{\ggcurly}{\mathrel}{mathb}{"CF}

%para pintar arboles bonitos...
\usepackage{tikz}
\usetikzlibrary{arrows}

\tikzset{
  	treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  	arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
 	arn_r/.style = {treenode, circle, white, draw=red, fill= red,
    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
  	arn_x/.style = {treenode, rectangle, white, draw=black, fill= black,
    minimum width=0.5em, minimum height=0.5em},% arbre rouge noir, nil
    arn_bb/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=gray,
    fill=gray, text width=1.5em},
    arn_nb/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
    fill=white, text width=1.5em},
    arn_w/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=brown,
    fill=brown, text width=1.5em},
    arn_xb/.style = {treenode, rectangle, white, draw=gray, fill= gray,
    minimum width=0.5em, minimum height=0.5em}
}
\begin{document}

\frame{\titlepage}

\section{1.Árboles Rojinegros}
\begin{frame}{Árboles Binarios}
Un Árbol binario es una estructura de datos no lineal, una definición formal de
estos es:
\begin{itemize}
    \item Gráfica conexa con vértices de grado a lo más 3.
\end{itemize}
Ejemplo:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 3cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-8,-7) grid (8,0);
\node [arn_nb] at (0,0) {}
	child{ node [arn_nb] {}
		   child{ node [arn_nb] {}}
		   child{ node [arn_nb] {}
			      child{ node [arn_nb] {}}
			      child{ node [arn_nb] {}}
		   }
	}
	child{ node [arn_nb] {}}

;

\end{tikzpicture}
\end{frame}

\begin{frame}{Árboles Binarios de Búsqueda}
Un Árbol binario de búsqueda es un caso particular de  un árbol binario, el
cual tiene las siguientes invariantes:
\begin{itemize}
    \item Todos los elementos del subárbol izquierdo son menores al elemento de
la raíz.
    \item Todos los elementos del subárbol derecho son mayores al elemento de la
raíz.
    \item Ambos subárboles también son de búsqueda.
\end{itemize}

\end{frame}


\begin{frame}{Árboles Binarios de Búsqueda}
Ejemplo:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 3cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-8,-7) grid (8,0);
\node [arn_nb] at (0,0) {7}
	child{ node [arn_nb] {2}
		   child{ node [arn_nb] {1}}
		   child{ node [arn_nb] {4}
			      child{ node [arn_nb] {3}}
			      child{ node [arn_nb] {5}}
		   }
	}
	child{ node [arn_nb] {10}}

;

\end{tikzpicture}

\end{frame}

\begin{frame}{Árboles Rojinegros}
Son un caso particular de arboles binarios de búsqueda, estos a su vez incluyen
más invariantes para garantizar una mayor eficiencia en las operaciones que se
pueden realizar con ellos. Las invariantes son:
\footnote[frame]{Estructuras de Datos con Java Moderno. Canek Paláez Váldes}
\begin{itemize}
    \item Todos los vértices son negros o rojos.
    \item La raíz es negra.
    \item Todas las hojas son negras, como la raíz.
    \item Un vértice rojo siempre tiene dos hijos negros.
    \item Para todo vértice $v$ de este árbol, todas las trayectorias de $v$ a
alguna de sus hojas descendientes tiene el mismo número de vértices negros.
\end{itemize}

\end{frame}

\begin{frame}{Árboles Rojinegros}
Ejemplo:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 4cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
    child{ node [arn_r] {2}
            child{ node [arn_n] {1}
            	child{ node [arn_x] {}} %for a named pointer
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
							child{ node [arn_r] {3}
								child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
							child{ node [arn_r] {5}
							    child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
            }
    }
    child{ node [arn_n] {8}
            child{ node [arn_x] {}
            }
            child{ node [arn_r] {9}
							child{ node [arn_x] {}}
							child{ node [arn_x] {}}
            }
		}
;


\end{tikzpicture}
\end{frame}


\section{2.Verificación Formal}

\begin{frame}
  \frametitle{Verificación de Árboles Rojinegros.}

  Los lenguajes de programación en los que generalmente se implementan este tipo
de arboles son del paradigma imperativo, por ejemplo Java, en los cuales una
manera de
  intentar verificar que la estructura funciona es usar pruebas unitarias.

  \vspace*{10pt}
  \centering Pero esto no es verificar.

\end{frame}

\section{3.Haskell}
\begin{frame}
  \frametitle{Verificación formal en Haskell}
    Haskell es un lenguaje de programaci\'on funcional con una base muy grande
de desarrolladores que constantemente están generando mas programas escritos en
el.
\vspace*{10pt}
    \newline Una de las cosas que se dice de Haskell es que la verificación de
su código es bastante sencilla.

\newline\centering{¿Pero qué tan cierto y escalable es esto?}
\end{frame}

\section{4.Coq}
\begin{frame}
  \frametitle{Verificación formal en Coq}
	A diferencia de Haskell, Coq es un asistente de pruebas, con el cual se
puede escribir un programa y a la par de demostrar su especificación formal.
\end{frame}

\begin{frame}
  \frametitle{Verificación formal en Coq}
    Las diferencias mas grandes entre la escritura de programas entre Haskell y
Coq, es que Coq solo acepta funciones totales y que estas terminen en todos sus
casos.
\end{frame}
\section{3.Motivación}
\begin{frame}
  \frametitle{Problema}
       Nos gustaría una manera de traducir módulos de Haskell (con funciones
totales) a Coq para poder verificarlas formalmente de una manera mas sencilla,
ordenada y escalable.
\end{frame}
\section{5.Haskell to Coq}
\begin{frame}
  \frametitle{hs-to-coq}
       Es una herramienta en desarrollo por un equipo de la Universidad de
Pensilvania (\url{https://github.com/antalsz/hs-to-coq}).

       En esta herramienta ya existen bibliotecas de Haskell traducidas a Coq y
también permite traducir cualquier programa de Haskell.
\end{frame}

\begin{frame}
  \frametitle{hs-to-coq}
        Esta herramienta es creada para facilitar la verificación, siguiendo los
siguientes pasos:
        \begin{enumerate}
            \item Escribir un módulo de Haskell, digamos un módulo de Árboles
Rojinegros.
            \item Probar ese código en Haskell por medio de ejemplos.
            \item Utilizar hs-to-coq para traducir el código a Coq.
            \item ¡A verificar!
        \end{enumerate}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Ventajas}
        Esto simplifica mucho la verificación en varios frentes:
         \begin{itemize}
            \item La traducción no se hace a mano.
            \item La cooperación en un equipo de trabajo se hace mas sencilla.
        \end{itemize}
\end{frame}
\section{6.Ejemplos}

\begin{frame}[fragile]
  \frametitle{Ejemplos}

  Definición de arboles rojinegros en Haskell
  \begin{lstlisting}[language=haskell]
  data Color = R | B

  data RB a = E | T Color (RB a) a (RB a)
  \end{lstlisting}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de balance de Árboles Rojinegros en Haskell.
       \begin{lstlisting}[language=haskell]
    balance :: RB a -> a -> RB a -> RB a
    balance (T R a x b) y (T R c z d) = T R (T B a x b) y (T B c z d)
    balance (T R (T R a x b) y c) z d = T R (T B a x b) y (T B c z d)
    balance (T R a x (T R b y c)) z d = T R (T B a x b) y (T B c z d)
    balance a x (T R b y (T R c z d)) = T R (T B a x b) y (T B c z d)
    balance a x (T R (T R b y c) z d) = T R (T B a x b) y (T B c z d)
    balance a x b = T B a x b
       \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de balance de Árboles Rojinegros en Coq, traducido con hs-to-coq.
       \begin{lstlisting}[language=Coq]
 Definition balance {a} : RB a -> a -> RB a -> RB a :=
  fun arg_0__ arg_1__ arg_2__ =>
    match arg_0__, arg_1__, arg_2__ with
    | T R a x b, y, T R c z d => T R (T B a x b) y (T B c z d)
    | T R (T R a x b) y c, z, d => T R (T B a x b) y (T B c z d)
    | T R a x (T R b y c), z, d => T R (T B a x b) y (T B c z d)
    | a, x, T R b y (T R c z d) => T R (T B a x b) y (T B c z d)
    | a, x, T R (T R b y c) z d => T R (T B a x b) y (T B c z d)
    | a, x, b => T B a x b
  end.
       \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de inserción de Árboles Rojinegros en Haskell.
       \begin{lstlisting}[language=haskell]
    ins :: Ord a => a -> RB a -> RB a
    ins x E = T R E x E
    ins x s@(T B a y b)
      | x<y = balance (ins x a) y b
      | x>y = balance a y (ins x b)
      | otherwise = s
    ins x s@(T R a y b)
      | x<y = T R (ins x a) y b
      | x>y = T R a y (ins x b)
      | otherwise = s
      
    insert :: Ord a => a -> RB a -> RB a
    insert x s = T B a z b where T _ a z b = ins x s
       \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de inserción de Árboles Rojinegros en Coq, traducido con hs-to-coq.
       \begin{lstlisting}[language=Coq]
Definition ins {a} `{GHC.Base.Ord a} : a -> RB a -> RB a :=
  fix ins arg_0__ arg_1__
        := match arg_0__, arg_1__ with
           | x, E => T R E x E
           | x, (T B a y b as s) =>
               if x GHC.Base.< y : bool then balance (ins x a) y b else
               if x GHC.Base.> y : bool then balance a y (ins x b) else
               s
           | x, (T R a y b as s) =>
               if x GHC.Base.< y : bool then T R (ins x a) y b else
               if x GHC.Base.> y : bool then T R a y (ins x b) else
               s
end.
       \end{lstlisting}
\end{frame}


\begin{frame}{Ejemplo Práctico}
Agregaremos el número 10:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 4cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
    child{ node [arn_r] {2}
            child{ node [arn_n] {1}
            	child{ node [arn_x] {}} %for a named pointer
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
							child{ node [arn_r] {3}
								child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
							child{ node [arn_r] {5}
							    child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
            }
    }
    child{ node [arn_n] {8}
            child{ node [arn_x] {}
            }
            child{ node [arn_r] {9}
							child{ node [arn_x] {}}
							child{ node [arn_x] {}}
            }
		}
;


\end{tikzpicture}

\end{frame}

\begin{frame}[fragile]{Ejemplo Práctico}
Se agrega como hijo rojo del 9.

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 4cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
    child{ node [arn_r] {2}
            child{ node [arn_n] {1}
            	child{ node [arn_x] {}} %for a named pointer
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
							child{ node [arn_r] {3}
								child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
							child{ node [arn_r] {5}
							    child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
            }
    }
    child{ node [arn_n] {8}
            child{ node [arn_x] {}
            }
            child{ node [arn_r] {9}
							child{ node [arn_x] {}}
							child{ node [arn_r] {10}
							    child{ node [arn_x] {}}
							    child{ node [arn_x] {}}}
            }
		}
;

\end{tikzpicture}
\begin{lstlisting}
case:10>9 
T R a 9 (T R E 10 E)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Ejemplo Práctico}
La función de balanceo mantiene el invariante todo el tiempo.

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 4cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
    child{ node [arn_r] {2}
            child{ node [arn_n] {1}
            	child{ node [arn_x] {}} %for a named pointer
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
							child{ node [arn_r] {3}
								child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
							child{ node [arn_r] {5}
							    child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
            }
    }
    child{ node [arn_r] {9}
            child{ node [arn_n] {8}
            child{ node [arn_x] {}}
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {10}
							child{ node [arn_x] {}}
							child{ node [arn_x] {}}
            }
		}
;

\end{tikzpicture}
\begin{lstlisting}
 balance E 8 (T R E 9 (T R E 10 E)) =
                    T R (T B E 8 E) 9 (T B E 10 E)
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{Por verificar...\footnote[frame]{https://softwarefoundations.cis.upenn.edu/draft/vfa-current/Redblack.html}}
    \begin{lstlisting}[language=coq]
Inductive is_redblack : tree -> color -> nat -> Prop :=
 | IsRB_leaf: forall c, is_redblack E c 0
 | IsRB_r: forall tl k kv tr n,
          is_redblack tl Red n ->
          is_redblack tr Red n ->
          is_redblack (T Red tl v tr) Black n
 | IsRB_b: forall c tl k kv tr n,
          is_redblack tl Black n ->
          is_redblack tr Black n ->
          is_redblack (T Black tl v tr) c (S n).

Lemma insert_is_redblack:
  forall x s n, is_redblack s Red n ->
                    exists n', is_redblack (insert x s) Red n'.
    \end{lstlisting}
    
\end{frame}

\section{7.Trabajo en desarrollo}
\begin{frame}
  \frametitle{Trabajo en desarrollo}
  La herramienta \textbf{hs-to-coq} est\'a en desarrollo y se le esta
integrando mas funcionalidades de Haskell, como clases, polimorfismos, etc.

\vspace*{10pt}

  Este es un trabajo en curso, se busca poder traducir y verificar
  las operaciones de los \'arboles rojinegros y tambi\'en las implementaciones
  de estos.
\footnote[frame]{Implementaciones funcionales de árboles roji-negros.
  Graciela López Campos}
\end{frame}


\end{document}
