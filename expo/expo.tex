%%% Presentaciones para Lenguajes de programacion y sus paradigmas

\documentclass[xcolor=dvipsnames,table,handout]{beamer}
%\documentclass[xcolor=dvipsnames,table]{beamer}
%\documentclass[xcolor=dvipsnames,table,spanish]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

%%%% paquetes matematicas
\usepackage{amssymb,amsmath,amscd}
\usepackage{extarrows}
\usepackage{stmaryrd}
\usepackage{mathabx}
\usepackage{mathrsfs}
% \usepackage{mathabx}
\usepackage{amsthm}

%%%%%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{xcolor}
\usepackage{etex}
\usepackage{tikz}
\usepackage{array}
\usepackage{listings}
%\usepackage{pgfplots}


\newtheorem{prop}{Proposición}

%%%% cosmetics
% D.Remy package for pretty display of rules
\usepackage{mathpartir}

% para insertar codigo con formato particular
\usepackage{listings}
% lstlisting Haskell style (inspired from a file of Assia Mahboubi)
%
\lstdefinelanguage{Haskell}{
%
% Anything betweeen $ becomes LaTeX math mode
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false,
%
morekeywords=[1]{class, instance},
%
morekeywords=[2]{where},
%
morekeywords=[3]{Maybe},
%
morekeywords=[4]{main},
%
morekeywords=[6]{do, last, first, try, idtac, repeat},
%
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d],
%
% Size of tabulations
tabsize=3,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
breaklines=false,
%
% Default style fors listings
basicstyle=\small,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{dkviolet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{dkgreen}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{ltblue}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{dkblue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{dkred}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{dkgreen}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {->}{{$\rightarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\\dollar}{{$\$$\;}}1
%
}[keywords,comments,strings]

\lstnewenvironment{haskell}{\lstset{language=Haskell}}{}

% lstlisting coq style (inspired from a file of Assia Mahboubi)
%
\lstdefinelanguage{Coq}{
%
% Anything betweeen $ becomes LaTeX math mode
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false,
%
% Vernacular commands
morekeywords=[1]{Section, Module, End, Require, Import, Export,
  Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
  Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
  Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
  Morphism, Relation, Implicit, Arguments, Unset, Contextual,
  Strict, Prenex, Implicits, Inductive, CoInductive, Record,
  Structure, Canonical, Coercion, Context, Class, Global, Instance,
  Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
  Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
  Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
  Projections, inside, outside, Def},
%
% Gallina
morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
  match, with, end, as, in, return, let, if, is, then, else, for, of,
  nosimpl, when},
%
% Sorts
morekeywords=[3]{Type, Prop, Set, true, false, option},
%
% Various tactics, some are std Coq subsumed by ssr, for the manual purpose
morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
  intro, intros, generalize, rename, pattern, after, destruct,
  induction, using, refine, inversion, injection, rewrite, congr,
  unlock, compute, ring, field, fourier, replace, fold, unfold,
  change, cutrewrite, simpl, have, suff, wlog, suffices, without,
  loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
  symmetry, transitivity, auto, split, left, right, autorewrite},
%
% Terminators
morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
  assumption, solve, contradiction, discriminate},
%
% Control
morekeywords=[6]{do, last, first, try, idtac, repeat},
%
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d],
%
% Size of tabulations
tabsize=3,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
breaklines=false,
%
% Default style fors listings
basicstyle=\small,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{dkviolet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{dkgreen}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{ltblue}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{dkblue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{dkred}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{dkgreen}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
%    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1
    {\\o}{{$\circ\;$}}1
    {\@}{{$\cdot$}}1
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
%
}[keywords,comments,strings]

\lstnewenvironment{coq}{\lstset{language=Coq}}{}

% pour inliner dans le texte
\def\coqe{\lstinline[language=Coq, basicstyle=\small]}
% pour inliner dans les tableaux / displaymath...
\def\coqes{\lstinline[language=Coq, basicstyle=\scriptsize]}

%%% Local Variables:
%%% mode: latex
%%% Local IspellDict: british
%%% TeX-master: "main.tex"
%%% End:

% pour inliner dans le texte
\def\hasqel{\lstinline[language=Haskell, basicstyle=\small]}
% pour inliner dans les tableaux / displaymath...
\def\haskels{\lstinline[language=Haskell, basicstyle=\scriptsize]}

%%% Local Variables:
%%% mode: latex
%%% Local IspellDict: british
%%% TeX-master: "main.tex"
%%% End:
% comillas
\usepackage[autostyle=true,spanish=mexican]{csquotes}

% codigo
\usepackage{verbatim}
\usepackage{alltt}

% footnotes
\usepackage[bottom]{footmisc}
\usepackage{setspace}

\usepackage{wrapfig}
\usepackage{caption}


\hfuzz=5.002pt %parameter to allow hbox overfulled by length before error!

% Options for presentation
% ------------------------
% \definecolor{mycolor}{RGB}{255,192,3}
\definecolor{mycolor}{RGB}{17,132,221}
\mode<presentation>
{
% \usetheme[secheader]{Boadilla}
% \usecolortheme{orchid}
\useoutertheme{infolines}
\useinnertheme{rectangles}
\setbeamertemplate{itemize items}[square]
\setbeamertemplate{enumerate items}[square]
\setbeamersize{text margin left=6mm, text margin right=6mm}

\setbeamercolor{alerted text}{fg=red,bg=red!70!white}
\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{frametitle}{bg=mycolor,fg=white}
\setbeamercolor{normal text}{bg=white,fg=black}
\setbeamercolor{structure}{bg=black,fg=mycolor}
\setbeamercolor{title}{bg=mycolor,fg=white}
\setbeamercolor{subtitle}{bg=mycolor,fg=white}
\setbeamercolor{titlelike}{bg=white,fg=mycolor}

\setbeamercovered{invisible}

\setbeamercolor*{palette primary}{fg=mycolor,bg=white}
\setbeamercolor*{palette secondary}{bg=white,fg=white}
\setbeamercolor*{palette tertiary}{fg=mycolor,bg=white}
\setbeamercolor*{palette quaternary}{fg=white,bg=white}

\setbeamercolor{separation line}{bg=mycolor,fg=mycolor}
\setbeamercolor{fine separation line}{bg=white,fg=red}
\setbeamercolor{author in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{title in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{date in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{institute in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{section in head/foot}{bg=mycolor!60!white, fg=white}
\setbeamercolor{subsection in head/foot}
{bg=mycolor!50!white,fg=mycolor!50!white}


\setbeamertemplate{headline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.65ex,dp=1.5ex,center]{section in
head/foot}%
    \usebeamerfont{section in head/foot}\insertsectionhead\hspace*{2ex}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.65ex,dp=1.5ex,center]{subsection
in head/foot}%
    \usebeamerfont{subsection in head/foot}\hspace*{2ex}\insertsubsectionhead
  \end{beamercolorbox}}%
  \vskip0pt%
}
% \beamerdefaultoverlayspecification{<+->}
\beamertemplatenavigationsymbolsempty
% \setbeamertemplate{footline}[frame number]
}

\input{macroslc}

\title[]{Verificación formal de arboles rojinegros en Haskell con Coq}
\author[]{David Felipe Hernández Chiapa}
\institute[UNAM-FC]{Facultad de Ciencias\\
Universidad Nacional Aut\'onoma de M\'exico}
\date[]{\small{\today}}



\beamerdefaultoverlayspecification{<+->}

\titlegraphic{\includegraphics[width=16mm]{fc2.png}
}

% Opciones extras
% L5: beamer en español
\usepackage[all]{xy}
\decimalpoint
% Counter para enumerates en varios frames
\newcounter{saveenumi}
\newcommand{\savei}{\setcounter{saveenumi}{\value{enumi}}}
\newcommand{\conti}{\setcounter{enumi}{\value{saveenumi}}}
\resetcounteronoverlays{saveenumi}
\definecolor{light-gray}{gray}{0.75}
\newcommand{\IF}{\operatorname{if}}
\newcommand{\THEN}{\operatorname{then}}
\newcommand{\ELSE}{\operatorname{else}}
\newcommand{\qn}{\operatorname{qn}}
\newcommand{\shift}{\operatorname{shift}}

\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{
<-6> mathb5 <6-7> mathb6 <7-8> mathb7
<8-9> mathb8 <9-10> mathb9
<10-12> mathb10 <12-> mathb12
}{}
\DeclareSymbolFont{mathb}{U}{mathb}{m}{n}
\DeclareMathSymbol{\llcurly}{\mathrel}{mathb}{"CE}
\DeclareMathSymbol{\ggcurly}{\mathrel}{mathb}{"CF}

%para pintar arboles bonitos...
\usepackage{tikz}
\usetikzlibrary{arrows}

\tikzset{
  	treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  	arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
 	arn_r/.style = {treenode, circle, white, draw=red, fill= red,
    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
  	arn_x/.style = {treenode, rectangle, white, draw=black, fill= black,
    minimum width=0.5em, minimum height=0.5em},% arbre rouge noir, nil
    arn_bb/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=gray,
    fill=gray, text width=1.5em},
    arn_nb/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
    fill=white, text width=1.5em},
    arn_w/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=brown,
    fill=brown, text width=1.5em},
    arn_xb/.style = {treenode, rectangle, white, draw=gray, fill= gray,
    minimum width=0.5em, minimum height=0.5em}
}
\begin{document}

\frame{\titlepage}

\section{1.Arboles Rojinegros}
\begin{frame}{Arboles Binarios}
Un Árbol binario es una estructura de datos no lineal, una definición formal de estos seria:
\begin{itemize}
    \item Gráfica conexa con vértices de grado a lo mas 3.
\end{itemize}
Ejemplo:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 3cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-8,-7) grid (8,0);
\node [arn_nb] at (0,0) {}
	child{ node [arn_nb] {}
		   child{ node [arn_nb] {}}
		   child{ node [arn_nb] {}
			      child{ node [arn_nb] {}}
			      child{ node [arn_nb] {}}
		   }
	}
	child{ node [arn_nb] {}}

;
\draw node [text width=7cm] at (0,-4.5)
{
\'Arbol binario.
}
;
\end{tikzpicture}
\end{frame}

\begin{frame}{Arboles Binarios de Búsqueda}
Un Árbol binario de búsqueda es un caso particular de  un árbol binarios, el cual tiene las siguientes invariantes:
\begin{itemize}
    \item Todos los elementos del subárbol izquierdo son menores al elemento de la raíz.
    \item Todos los elementos del subárbol derecho son mayores al elemento de la raíz.
    \item Ambos subárboles también son de búsqueda.
\end{itemize}

\end{frame}


\begin{frame}{Arboles Binarios de Búsqueda}
Ejemplo:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 3cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-8,-7) grid (8,0);
\node [arn_nb] at (0,0) {7}
	child{ node [arn_nb] {2}
		   child{ node [arn_nb] {1}}
		   child{ node [arn_nb] {4}
			      child{ node [arn_nb] {3}}
			      child{ node [arn_nb] {5}}
		   }
	}
	child{ node [arn_nb] {10}}

;
\draw node [text width=7cm] at (0,-4.5)
{
\'Arbol binario de búsqueda.
}
;
\end{tikzpicture}

\end{frame}

\begin{frame}{Arboles Rojinegros}
Son un caso particular de arboles binarios de búsqueda, estos a su vez incluyen mas invariantes para garantizar una mayor eficiencia en las operaciones que se pueden realizar con ellos. Las invariantes son:
\begin{itemize}
    \item Todos los vértices son negros o rojos.
    \item La raíz es negra.
    \item Todas las hojas son negras, como la raíz.
    \item Un vértice rojo siempre tiene dos hijos negros.
    \item Para todo vértice $v$ de este árbol, todas las trayectorias de $v$ a alguna de sus hojas descendientes tiene el mismo número de vértices negros.
\end{itemize}

\end{frame}

\begin{frame}{Arboles Rojinegros}
Ejemplo:

\centering
    \begin{tikzpicture}[-,>=stealth',level/.style={sibling distance = 4cm/#1,
  level distance = 1cm}]
%\draw[style=help lines] (-5,-7) grid (5,0);
\node [arn_n] at (-2,0) {6}
    child{ node [arn_r] {2}
            child{ node [arn_n] {1}
            	child{ node [arn_x] {}} %for a named pointer
							child{ node [arn_x] {}}
            }
            child{ node [arn_n] {4}
							child{ node [arn_r] {3}
								child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
							child{ node [arn_r] {5}
							    child{ node [arn_x] {}}
								child{ node [arn_x] {}}}
            }
    }
    child{ node [arn_n] {8}
            child{ node [arn_x] {}
            }
            child{ node [arn_r] {9}
							child{ node [arn_x] {}}
							child{ node [arn_x] {}}
            }
		}
;
\draw node [text width=7cm] at (-1,-4.5)
{
\'Arbol roji-negro con vac\'ios.
}
;

\end{tikzpicture}
\end{frame}


\section{2.Verificación Formal}

\begin{frame}
  \frametitle{Verificación de Arboles Rojinegros.}

  Los lenguajes de programación en los que generalmente se implementan este tipo de arboles son del paradigma imperativo, por ejemplo Java, en los cuales una manera de
  intentar verificar que la estructura funciona es usar pruebas unitarias.

\newline \newline \centering Pero esto no es verificar.

\end{frame}

\section{3.Haskell}
\begin{frame}
  \frametitle{Verificación formal en Haskell}
    Haskell es un lenguaje con una base muy grande de desarrolladores que constantemente están generando mas programas escritos en el.
    \newline Una de las cosas que se dice de Haskell es que la verificación de su código es bastante sencilla.

\newline\centering{¿Pero qué tan cierto y escalable es esto?}
\end{frame}

\section{4.Coq}
\begin{frame}
  \frametitle{Verificación formal en Coq}
	A diferencia de Haskell, Coq es un asistente de pruebas, con el cual se puede escribir un programa y a la par de demostrar su especificación formal.
\end{frame}

\begin{frame}
  \frametitle{Verificación formal en Coq}
    Las diferencias mas grandes entre la escritura de programas entre Haskell y Coq, es que Coq solo acepta funciones totales y que estas terminen en todos sus casos.
\end{frame}
\section{3.Motivación}
\begin{frame}
  \frametitle{Problema}
       Nos gustaría una manera de traducir módulos de Haskell (con funciones totales) a Coq para poder verificarlas formalmente de una manera mas sencilla, ordenada y escalable.
\end{frame}
\section{5.Haskell to Coq}
\begin{frame}
  \frametitle{hs-to-coq}
       Es una herramienta en desarrollo por un equipo de la Universidad de Pensilvania (\url{https://github.com/antalsz/hs-to-coq}).

       En esta herramienta ya existen bibliotecas de Haskell traducidas a Coq y también permite traducir cualquier programa de Haskell.
\end{frame}

\begin{frame}
  \frametitle{hs-to-coq}
        Esta herramienta es creada para facilitar la verificación, siguiendo los siguientes pasos:
        \begin{enumerate}
            \item Escribir un módulo de Haskell, digamos un módulo de Arboles Rojinegros.
            \item Probar ese código en Haskell por medio de ejemplos.
            \item Utilizar hs-to-coq para traducir el código a Coq.
            \item ¡A verificar!
        \end{enumerate}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Ventajas}
        Esto simplifica mucho la verificación en varios frentes:
         \begin{itemize}
            \item La traducción no se hace a mano.
            \item La cooperación en un equipo de trabajo se hace mas sencilla.
        \end{itemize}
\end{frame}
\section{6.Ejemplos}

\begin{frame}[fragile]
  \frametitle{Ejemplos}

  Definición de arboles rojinegros en Haskell
  \begin{lstlisting}[language=haskell]
  data Color = R | B

  data RB a = E | T Color (RB a) a (RB a)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de balance de Arboles Rojinegros en Haskell.
       \begin{lstlisting}[language=haskell]
    balance :: RB a -> a -> RB a -> RB a
    balance (T R a x b) y (T R c z d) = T R (T B a x b) y (T B c z d)
    balance (T R (T R a x b) y c) z d = T R (T B a x b) y (T B c z d)
    balance (T R a x (T R b y c)) z d = T R (T B a x b) y (T B c z d)
    balance a x (T R b y (T R c z d)) = T R (T B a x b) y (T B c z d)
    balance a x (T R (T R b y c) z d) = T R (T B a x b) y (T B c z d)
    balance a x b = T B a x b
       \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de balance de Arboles Rojinegros en Coq, traducido con hs-to-coq.
       \begin{lstlisting}[language=Coq]
 Definition balance {a} : RB a -> a -> RB a -> RB a :=
  fun arg_0__ arg_1__ arg_2__ =>
    match arg_0__, arg_1__, arg_2__ with
    | T R a x b, y, T R c z d => T R (T B a x b) y (T B c z d)
    | T R (T R a x b) y c, z, d => T R (T B a x b) y (T B c z d)
    | T R a x (T R b y c), z, d => T R (T B a x b) y (T B c z d)
    | a, x, T R b y (T R c z d) => T R (T B a x b) y (T B c z d)
    | a, x, T R (T R b y c) z d => T R (T B a x b) y (T B c z d)
    | a, x, b => T B a x b
  end.
       \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de inserción de Arboles Rojinegros en Haskell.
       \begin{lstlisting}[language=haskell]
    ins :: Ord a => a -> RB a -> RB a
    ins x E = T R E x E
    ins x s@(T B a y b)
      | x<y = balance (ins x a) y b
      | x>y = balance a y (ins x b)
      | otherwise = s
    ins x s@(T R a y b)
      | x<y = T R (ins x a) y b
      | x>y = T R a y (ins x b)
      | otherwise = s
       \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ejemplos}
  Código de inserción de Arboles Rojinegros en Coq, traducido con hs-to-coq.
       \begin{lstlisting}[language=Coq]
Definition ins {a} `{GHC.Base.Ord a} : a -> RB a -> RB a :=
  fix ins arg_0__ arg_1__
        := match arg_0__, arg_1__ with
           | x, E => T R E x E
           | x, (T B a y b as s) =>
               if x GHC.Base.< y : bool then balance (ins x a) y b else
               if x GHC.Base.> y : bool then balance a y (ins x b) else
               s
           | x, (T R a y b as s) =>
               if x GHC.Base.< y : bool then T R (ins x a) y b else
               if x GHC.Base.> y : bool then T R a y (ins x b) else
               s
end.
       \end{lstlisting}
\end{frame}

\section{7.Trabajo en desarrollo}
\begin{frame}
  \frametitle{Trabajo en desarrollo}
  La herramienta que se usa (hs-to-coq) esta en desarrollo y se le esta integrando mas funcionalidades de Haskell, como clases, polimorfismos, etc.

  Este es un trabajo en curso, se busca poder traducir y verificar las operaciones de los arboles rojinegros y tambien as implementacioenes de estos (Implementaciones funcionales de árboles roji-negros,Graciela Lópesz Campos).
\end{frame}


\end{document}
