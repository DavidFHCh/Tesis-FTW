%%% Presentaciones para Lenguajes de programacion y sus paradigmas

%\documentclass[xcolor=dvipsnames,table,handout]{beamer}
%\documentclass[xcolor=dvipsnames,table]{beamer}
\documentclass[xcolor=dvipsnames,table,spanish]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

%%%% paquetes matematicas
\usepackage{amssymb,amsmath,amscd}
\usepackage{extarrows}
\usepackage{stmaryrd}
\usepackage{mathabx}
\usepackage{mathrsfs}
% \usepackage{mathabx}
\usepackage{amsthm}

%%%%%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{xcolor}
\usepackage{etex}
\usepackage{tikz}
\usepackage{array}
%\usepackage{pgfplots}


\newtheorem{prop}{Proposición}

%%%% cosmetics
% D.Remy package for pretty display of rules
\usepackage{mathpartir}

% para insertar codigo con formato particular
\usepackage{listings}

% comillas
\usepackage[autostyle=true,spanish=mexican]{csquotes}

% codigo
\usepackage{verbatim}
\usepackage{alltt}

% footnotes
\usepackage[bottom]{footmisc}
\usepackage{setspace}

\usepackage{wrapfig}
\usepackage{caption}


\hfuzz=5.002pt %parameter to allow hbox overfulled by length before error!

% Options for presentation
% ------------------------
% \definecolor{mycolor}{RGB}{255,192,3}
\definecolor{mycolor}{RGB}{17,132,221}
\mode<presentation>
{
% \usetheme[secheader]{Boadilla}
% \usecolortheme{orchid}
\useoutertheme{infolines}
\useinnertheme{rectangles}
\setbeamertemplate{itemize items}[square]
\setbeamertemplate{enumerate items}[square]
\setbeamersize{text margin left=6mm, text margin right=6mm}

\setbeamercolor{alerted text}{fg=red,bg=red!70!white}
\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{frametitle}{bg=mycolor,fg=white}
\setbeamercolor{normal text}{bg=white,fg=black}
\setbeamercolor{structure}{bg=black,fg=mycolor}
\setbeamercolor{title}{bg=mycolor,fg=white}
\setbeamercolor{subtitle}{bg=mycolor,fg=white}
\setbeamercolor{titlelike}{bg=white,fg=mycolor}

\setbeamercovered{invisible}

\setbeamercolor*{palette primary}{fg=mycolor,bg=white}
\setbeamercolor*{palette secondary}{bg=white,fg=white}
\setbeamercolor*{palette tertiary}{fg=mycolor,bg=white}
\setbeamercolor*{palette quaternary}{fg=white,bg=white}

\setbeamercolor{separation line}{bg=mycolor,fg=mycolor}
\setbeamercolor{fine separation line}{bg=white,fg=red}
\setbeamercolor{author in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{title in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{date in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{institute in head/foot}{bg=mycolor!30!white,fg=mycolor!80!black}
\setbeamercolor{section in head/foot}{bg=mycolor!60!white, fg=Red}
\setbeamercolor{subsection in head/foot}
{bg=mycolor!50!white,fg=mycolor!50!white}


\setbeamertemplate{headline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.65ex,dp=1.5ex,center]{section in
head/foot}%
    \usebeamerfont{section in head/foot}\insertsectionhead\hspace*{2ex}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.65ex,dp=1.5ex,center]{subsection
in head/foot}%
    \usebeamerfont{subsection in head/foot}\hspace*{2ex}\insertsubsectionhead
  \end{beamercolorbox}}%
  \vskip0pt%
}
% \beamerdefaultoverlayspecification{<+->}
\beamertemplatenavigationsymbolsempty
% \setbeamertemplate{footline}[frame number]
}

\input{macroslc}

\title[]{Lenguajes de programación y sus paradigmas}
\subtitle{Tema: Excepciones}
\author[]{}
\institute[UNAM-FC]{Facultad de Ciencias\\
Universidad Nacional Aut\'onoma de M\'exico}
\date[]{\small{\today}
\newline{\tiny{Material desarrollado bajo el proyecto UNAM-PAPIME PE102117.}}}


\beamerdefaultoverlayspecification{<+->}

\titlegraphic{\includegraphics[width=16mm]{fc2.png}
}

% Opciones extras
% L5: beamer en español
\usepackage[all]{xy}
\decimalpoint
% Counter para enumerates en varios frames
\newcounter{saveenumi}
\newcommand{\savei}{\setcounter{saveenumi}{\value{enumi}}}
\newcommand{\conti}{\setcounter{enumi}{\value{saveenumi}}}
\resetcounteronoverlays{saveenumi}
\definecolor{light-gray}{gray}{0.75}
\newcommand{\IF}{\operatorname{if}}
\newcommand{\THEN}{\operatorname{then}}
\newcommand{\ELSE}{\operatorname{else}}
\newcommand{\qn}{\operatorname{qn}}
\newcommand{\shift}{\operatorname{shift}}

\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{
<-6> mathb5 <6-7> mathb6 <7-8> mathb7
<8-9> mathb8 <9-10> mathb9
<10-12> mathb10 <12-> mathb12
}{}
\DeclareSymbolFont{mathb}{U}{mathb}{m}{n}
\DeclareMathSymbol{\llcurly}{\mathrel}{mathb}{"CE}
\DeclareMathSymbol{\ggcurly}{\mathrel}{mathb}{"CF}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{1. Idea}
	En la programación existen situaciones donde una función o 		procedimiento no pueda terminar su ejecución y deba de 			reportar este hecho a su emisor.

	\begin{examples}
	\begin{itemize}
		\item División entre cero.
		\item Desborde del rango aritmético.
		\item Índice de un arreglo fuera de rango.
        \item Archivo no accesible.
        \item Sistema sin memoria.
        \item Proceso terminado por usuario.
	\end{itemize}
    \end{examples}
\end{frame}

\begin{frame}
  \frametitle{1. Idea}
	Algunas de las condiciones anteriores pueden ser manejadas al cambiar el rango de la función que las provoca.

  	\begin{example}
    La función predecesor regresaria lo siguiente:\newline
    \begin{itemize}
        \item \texttt{trivial()}, en caso de ser 0 el argumento.\newline
  	    \item \texttt{Maybe Nat} $=_{def}$ 1 + \texttt{Nat}, en otro caso.
    \end{itemize}
  	\end{example}

\end{frame}

\begin{frame}
  \frametitle{2. Excepciones sin manejo}
  La manera mas simple de introducir excepciones es mediante un costructor \textbf{error}, el cual causa la detención total del programa.\newline

  La sintaxis se extiende con una constante de error:
  \begin{center}
      $e::=...|error$
  \end{center}
  La evaluacion se extiende de la siguiente manera:
  \begin{center}
      \begin{equation*}
         \frac{}{app(error,e_2)\imp error}
	  \end{equation*}
      \begin{equation*}
         \frac{}{app(v_1,error)\imp error}
	  \end{equation*}
  \end{center}
Notese que \textbf{error} no es un valor, entonces el programa $(\lambda x: Nat.0)error$, por un lado se reduciria a 0 y por el otro a error.
\end{frame}


\begin{frame}
\frametitle{2. Excepciones sin manejo}
	La semántica estática se extiende mediante:
	\begin{equation*}
         \frac{}{\Gamma \vdash error : T}
	\end{equation*}
    Esto permite que error reciba cualquier tipo. Esto es la unicidad de tipos, lo cual es importante a nivel practico. Se podría resolver esto de la siguiente manera:
    \begin{equation*}
         \frac{}{\Gamma \vdash error_T: T}
	\end{equation*}
    Sin embargo, de esta manera la preservación de tipos se destruye. Por lo siguiente:
    \begin{equation*}
         (\lambda x: Nat.x)((\lambda y:Bool.5)error_{Bool})\imp(\lambda x: Nat.x) error_{Bool}
	\end{equation*}
   Esto significa que tendremos que conformarnos con la perdida de la unicidad de tipos. Entonces se debe de reformular el progreso del sistema al ser que la expresión $error$ es una forma normal que no es un valor.

\end{frame}

\begin{frame}
\frametitle{2. Excepciones sin manejo}
\begin{prop}
Si $\vdash e:T$ entonces sucede una y solo una de las siguientes situaciones:
\begin{enumerate}
\item $e$ es un valor
\item Existe $e'$ tal que $e \imp e'$
\item $e = error$
\end{enumerate}
\end{prop}
\end{frame}

\begin{frame}
\frametitle{3. Manejo de Excepciones}
Ahora se mostrara un mejor uso de las excepciones al no abortar completamente la ejecución del programa y manejar las excepciones de manera que el programa de un salto.

\end{frame}

\begin{frame}
\frametitle{3. Manejo de Excepciones}
Hasta ahora lo que hacemos es detener la ejecución y devolver $error$ como resultado de la evaluación, lo cual quiere decir que lo que se hace es que se están eliminando los récords de activación de la pila de ejecución, otra manera de decirlo es que el error se propaga totalmente en la pila de ejecución.
\end{frame}

\begin{frame}
\frametitle{3. Manejo de Excepciones}
Una opción menos radical es instalar \textit{manejadores de excepciones} de tal manera que al surgir un error, se lanza una excepción que elimina los récords de activación hasta que encuentra un manejador, al cual se le transfiere el control del programa.
\end{frame}

\begin{frame}
\frametitle{3. Manejo de Excepciones}
Definimos ahora un lenguaje con una forma simple de manejo de excepciones.\newline
La sintaxis concreta se extiende mediante:
\begin{center}
      $e::=...|error|try$ $e_1$ $catch$ $e_2$
\end{center}
La sintaxis abstracta es:
\begin{center}
      $e::=...|error|catch(e_1,e_2)$
\end{center}
\end{frame}

\begin{frame}
\frametitle{3. Manejo de Excepciones}
La nueva expresión $catch(e_1,e_2)$ se evalúa como sigue: se intenta evaluar $e_1$ y si esta evaluación termina normalmente se devuelve su valor. Si la evaluación de $e_1$ resulta anormal, entonces surgirá un error y se procederá a evaluar $e_2$. Esto se formaliza de la siguiente manera:

 \begin{center}
      \begin{equation*}
         \frac{e_1 \imp e_1'}{catch(e_1,e_2) \imp catch(e_1',e_2)}
	  \end{equation*}
      \begin{equation*}
         \frac{}{catch(v,e_2) \imp v}
         \qquad
           \frac{}{catch(error,e_2) \imp e_2}
	  \end{equation*}

  \end{center}
\end{frame}

\begin{frame}
\frametitle{3. Manejo de Excepciones}
La semántica estática esta dada por la siguiente regla:
\begin{center}
      \begin{equation*}
         \frac{\Gamma \vdash e_1:T \quad \Gamma \vdash e_2:T}{\Gamma \vdash catch(e_1,e_2):T}
	  \end{equation*}
  \end{center}
  Con esto se observa que tanto $e_1$, $e_2$ y $catch(e_1,e_2)$ deben de tener el mismo tipo, ya que la evaluación del catch podría regresar $e_1$ o $e_2$.
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
Extendemos la maquina K para modelar la idea de navegar la pila hasta hallar un manejador. Esto es como sigue:
\begin{itemize}
		\item La evaluación de un catch instala un manejador en la pila de control.
		\item La evaluación de un error atraviesa la pila eliminando marcos hasta hallar el manejador mas cercano.
		\item La evaluación continua según lo dictado por este manejador, el cual utiliza la misma pila de control de manera que si hay errores en él se propagarán de la misma manera.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
Se introduce una nueva clase de estado, denotado como: \[\textrm{\textit{P}} \llcurly error\] Cuya intención es devolver y propagar un error en la pila \textrm{\textit{P}}, en búsqueda del manejador mas cercano.\newline El estado de la forma: \[ \square \llcurly error \] Se considera final y es el caso donde el error se propago completamente, vació la pila y aborto totalmente la ejecución del programa.
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
La categoría de marcos se extiende con uno que indica el cómputo pendiente al evaluar la expresión $e_1$, es decir un manejador:

\[\frac{}{catch(-,e_2) \quad marco}\]

\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
A continuación enunciamos y explicamos las nuevas transiciones:
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
\begin{itemize}
		\item Si se quiere evaluar un error entonces se causa el efecto de propagarlo en la pila.
        \[ \frac{}{\textrm{\textit{P}} \succ error \imp _K  \textrm{\textit{P}} \llcurly error}\]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
\begin{itemize}
		\item La evaluación de un manejador $catch(e_1,e_2)$ se inicia al evaluar $e_1$
        \[ \frac{}{\textrm{\textit{P}} \succ catch(e_1,e_2) \imp _K catch(-,e_2);\textrm{\textit{P}} \succ e_1} \]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
\begin{itemize}
		\item Si la evaluación de $e_1$ es exitosa, devolver su valor $v_1$ se elimina el marco manejador y el control del programa continua sin salto.
        \[ \frac{}{catch(-,e2) ; \textrm{\textit{P}} \succ v \imp _K \textrm{\textit{P}} \succ v} \]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
\begin{itemize}
		\item Propagar un error en una pila $m;\textrm{\textit{P}}$  consiste en eliminar el marco tope $m$ y propagar el error
en $\textrm{\textit{P}}$, siempre y cuando m no represente el computo pendiente de un manejador.
        \[ \frac{m \neq catch(-,e_2)}{m;\textrm{\textit{P}} \llcurly error \imp _K \textrm{\textit{P}} \llcurly error} \]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{3.1 Extensión de la máquina K}
\begin{itemize}
		\item Propagar un error en la pila con tope $catch(-,e_2)$ consiste en eliminar el manejador y continuar la evaluación con $e_2$.
        \[ \frac{}{catch(-,e2);\textrm{\textit{P}} \llcurly error \imp _K \textrm{\textit{P}} \succ e_2} \]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{3.2 Resolución de alcance}
El alcance de en una expresión \textbf{try...catch}, a diferencia de una expresión \textbf{let}, se resuelve de manera dinámica.

\end{frame}

\begin{frame}[fragile]
\frametitle{3.2 Resolución de alcance}
Considérense los siguientes ejemplos:\newline
Por la  resolución dinámica del \textbf{try...catch} el siguiente código se evalúa a 1.
\begin{example}
\begin{lstlisting}[language=Haskell]
try
  let f = fun(x:Nat) => error
      g = fun(h:Nat->Nat) =>
      	try (h 0) catch 1
  in
    try (g f) catch 2
  end
catch
  3

\end{lstlisting}
\end{example}
\end{frame}

\begin{frame}[fragile]
\frametitle{3.2 Resolución de alcance}
Y en este código por la resolución estática del \textbf{let}, se regresa 3.
\begin{example}
\begin{lstlisting}[language=Haskell]
let fail = 3 in
  let f = fun(x:Nat) => fail
      g = fun(h:Nat->Nat) =>
      	let fail = 1 in (h 0) end
  in
    let fail = 2 in (g f) end
  end
end

\end{lstlisting}
\end{example}
\end{frame}

\begin{frame}
\frametitle{3.3 Extensión con referencias y excepciones}
La semántica que permite extender el lenguaje núcleo imperativo con excepciones requiere de una generalización de la maquina $\mathcal{K}$ con memorias, los estados son de la forma: $\langle \mu , \mathcal{P} , e \rangle$ y las transiciones de la siguiente forma.
\[\langle \mu , \mathcal{P} , e \rangle \imp \langle \mu ', \mathcal{P}' , e' \rangle\]

Donde $\mu$ es una memoria, $mathcal{P}$ es una pila de control y $e$ es una expresión.
\end{frame}
\begin{frame}
\frametitle{3.3 Extensión con referencias y excepciones}
Como antes el proceso para manejar una excepción consiste en atravesar la pila hasta donde se halle el manejador más cercano, es decir, un $catch(-,e_2)$. Pero existen dos maneras de definir la interacción entre referencias y excepciones:

\begin{itemize}
\item Semántica estándar: La memoria $\mu$ al iniciar la evaluación de $e_2$ es la misma que estaba en uso en el momento en que la excepción fue lanzada.
\item Semántica transaccional: La memoria $\mu$ al iniciar la evaluación de $e_2$, aquella utilizada en el momento en el manejador $catch(-,e_2)$ fue instalado en la pila de control. Es decir, una excepción deshace cualquier efecto anterior.
\end{itemize}
\end{frame}
\begin{frame}
\frametitle{3.4 Uso de excepciones para optimizar programas}
Las excepciones no solo se pueden usar para manejar errores, también pueden usarse para optimizar código. Por ejemplo para causar un corto circuito en la evaluación de una expresión profundamente anidada.

\end{frame}

\begin{frame}[fragile]
\frametitle{3.4 Uso de excepciones para optimizar programas}
Consideremos el siguiente código que implementa la función de igualdad entre listas:

\begin{lstlisting}[language=Haskell]
fun lsteq(l1:[T],l2:[T]):Bool =>
  lsteq ([],[]) = true
| lsteq ((x:xs),(y:ys)) = x == y and lsteq (xs,ys)
| lsteq (_,_) = false
\end{lstlisting}

Si comparáramos dos listas de tamaño 1000000 tales que solo difieren en su ultimo elemento, el programa anterior tendría que liberar 100000 cómputos antes de de contestar false. Entre otras cosas, se debe a que no es recursiva de cola.
\end{frame}
\begin{frame}[fragile]
\frametitle{3.4 Uso de excepciones para optimizar programas}
En su lugar podemos implementar una función usando el poder del paradigma imperativo.

\begin{lstlisting}[language=Haskell]
fun leqaux(l1:[T],l2:[T]):Void =>
  leqaux ([],[]) = void
| leqaux ((x:xs),(y:ys)) = if x == y
                           then leqaux(xs,ys)
                           else error
| leqaux (_,_) = error

fun lsteq(l1:[T],l2:[T]):Bool =>
  try (leqaux (l1,l2));true catch false
\end{lstlisting}

En este caso, al lanzar la excepción, no hay necesidad de liberar cómputos pendientes o atravesar la pila, pues se devolverá false de inmediato.
\end{frame}
\begin{frame}
\frametitle{4 Excepciones con valor}
La forma más general de manejo de errores, además de lanzar una excepción al surgir un error y permitir un salto en el control del programa, nos gustaría que  pudiera reportar el hecho por el que el error surgió. A continuación tratamos esta forma general de excepciones.
\end{frame}

\begin{frame}

La sintaxis concreta se extiende como sigue:

\[e::=...|raise \quad e|handle \quad e_1 \quad with \quad x \Rightarrow \quad e_2\]
\newline
La sintaxis abstracta se extiende como sigue:
\[e::=...|raise(e)|handle(e_1,x.e_2\]
\end{frame}
\begin{frame}

\end{frame}
\begin{frame}

\end{frame}


\end{document}
